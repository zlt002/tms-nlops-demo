---
title: "TMS NL-Ops演示系统任务028: 流式处理和实时响应实现"
epic: "tms-nlops-demo"
task: "028"
phase: "4"
status: "pending"
priority: "high"
estimated_hours: 8
parallel: true
depends_on: ["027"]
tags: ["streaming", "realtime", "websocket", "sse", "performance"]
created: "2025-09-20T04:20:45Z"
updated: "2025-09-20T04:20:45Z"
---

## 概述

为TMS NL-Ops演示系统实现流式处理和实时响应机制，包括Server-Sent Events (SSE)、WebSocket支持、流式UI更新和实时数据推送，提供流畅的用户体验。

## 目标

- 实现Server-Sent Events (SSE) 流式响应
- 支持WebSocket双向通信
- 实现实时UI组件更新
- 提供流式数据处理和缓冲机制
- 建立连接管理和错误恢复机制

## 技术栈

- **流式协议**: Server-Sent Events (SSE)
- **双向通信**: WebSocket
- **流式处理**: LangGraph.js v1流式API
- **实时更新**: React状态管理
- **性能优化**: 防抖、节流、缓冲策略

## 实施步骤

### 1. 创建流式响应处理器

创建`agent/streaming/stream-processor.ts`:

```typescript
import { RunnableConfig } from "@langchain/core/runnables"
import { TMSAgentState } from "../types/state-annotations"
import { BaseMessage } from "@langchain/core/messages"
import { v4 as uuidv4 } from 'uuid'

export interface StreamEvent {
  id: string
  type: 'message' | 'tool_call' | 'tool_result' | 'ui_update' | 'error' | 'status' | 'complete'
  data: any
  timestamp: Date
  metadata?: Record<string, any>
}

export interface StreamProcessorConfig {
  enableBuffering?: boolean
  bufferSize?: number
  flushInterval?: number
  enableCompression?: boolean
  maxEventRate?: number
  enableRetry?: boolean
}

export class StreamProcessor {
  private config: StreamProcessorConfig
  private eventBuffer: StreamEvent[] = []
  private listeners: Map<string, (event: StreamEvent) => void> = new Map()
  private flushTimer: NodeJS.Timeout | null = null
  private eventRate: number = 0
  private lastEventTime: Date = new Date()

  constructor(config: StreamProcessorConfig = {}) {
    this.config = {
      enableBuffering: true,
      bufferSize: 10,
      flushInterval: 100, // 100ms
      enableCompression: false,
      maxEventRate: 100, // 每秒最大事件数
      enableRetry: true,
      ...config
    }

    this.setupFlushTimer()
  }

  // 处理LangGraph流式输出
  async processLangGraphStream(
    stream: AsyncIterable<any>,
    config: RunnableConfig
  ): Promise<AsyncIterable<StreamEvent>> {
    const eventId = uuidv4()

    return this.transformStream(stream, async (chunk) => {
      const events: StreamEvent[] = []

      // 处理消息更新
      if (chunk.messages) {
        const lastMessage = chunk.messages[chunk.messages.length - 1]
        if (lastMessage) {
          events.push({
            id: `${eventId}_msg_${Date.now()}`,
            type: 'message',
            data: {
              role: lastMessage.role,
              content: lastMessage.content,
              tool_calls: lastMessage.tool_calls
            },
            timestamp: new Date()
          })
        }
      }

      // 处理工具调用
      if (chunk.tool_calls) {
        for (const toolCall of chunk.tool_calls) {
          events.push({
            id: `${eventId}_tool_${toolCall.id}`,
            type: 'tool_call',
            data: {
              id: toolCall.id,
              name: toolCall.name,
              args: toolCall.args
            },
            timestamp: new Date()
          })
        }
      }

      // 处理UI更新
      if (chunk.ui && chunk.ui.component) {
        events.push({
          id: `${eventId}_ui_${Date.now()}`,
          type: 'ui_update',
          data: chunk.ui,
          timestamp: new Date()
        })
      }

      // 处理状态更新
      if (chunk.metadata) {
        events.push({
          id: `${eventId}_status_${Date.now()}`,
          type: 'status',
          data: {
            stepCount: chunk.metadata.stepCount,
            executionTime: chunk.metadata.performance?.totalTime || 0,
            toolCalls: chunk.metadata.toolCalls?.length || 0
          },
          timestamp: new Date()
        })
      }

      return events
    })
  }

  // 发送事件
  async sendEvent(event: StreamEvent): Promise<void> {
    // 速率限制
    if (this.config.maxEventRate) {
      const now = new Date()
      const timeDiff = now.getTime() - this.lastEventTime.getTime()
      const currentRate = 1000 / timeDiff

      if (currentRate > this.config.maxEventRate) {
        // 超过速率限制，丢弃或缓冲事件
        if (this.config.enableBuffering && this.eventBuffer.length < this.config.bufferSize!) {
          this.eventBuffer.push(event)
          return
        }
      }
    }

    this.lastEventTime = new Date()

    if (this.config.enableBuffering) {
      this.eventBuffer.push(event)
      this.maybeFlushEvents()
    } else {
      this.emitEvent(event)
    }
  }

  // 批量发送事件
  async sendEvents(events: StreamEvent[]): Promise<void> {
    for (const event of events) {
      await this.sendEvent(event)
    }
  }

  // 添加事件监听器
  addEventListener(id: string, callback: (event: StreamEvent) => void): void {
    this.listeners.set(id, callback)
  }

  // 移除事件监听器
  removeEventListener(id: string): void {
    this.listeners.delete(id)
  }

  // 清理资源
  destroy(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer)
      this.flushTimer = null
    }
    this.listeners.clear()
    this.eventBuffer = []
  }

  private setupFlushTimer(): void {
    if (this.config.enableBuffering && this.config.flushInterval) {
      this.flushTimer = setInterval(() => {
        this.flushEvents()
      }, this.config.flushInterval)
    }
  }

  private maybeFlushEvents(): void {
    if (this.eventBuffer.length >= this.config.bufferSize!) {
      this.flushEvents()
    }
  }

  private flushEvents(): void {
    if (this.eventBuffer.length === 0) return

    const events = [...this.eventBuffer]
    this.eventBuffer = []

    // 可以在这里进行事件压缩或合并
    const optimizedEvents = this.optimizeEvents(events)

    for (const event of optimizedEvents) {
      this.emitEvent(event)
    }
  }

  private emitEvent(event: StreamEvent): void {
    for (const [id, callback] of this.listeners) {
      try {
        callback(event)
      } catch (error) {
        console.error(`Event listener error for ${id}:`, error)
      }
    }
  }

  private optimizeEvents(events: StreamEvent[]): StreamEvent[] {
    // 优化策略：合并连续的消息更新
    const optimized: StreamEvent[] = []
    let lastMessageEvent: StreamEvent | null = null

    for (const event of events) {
      if (event.type === 'message' && lastMessageEvent) {
        // 合并消息内容
        lastMessageEvent.data.content += event.data.content
        lastMessageEvent.timestamp = event.timestamp
      } else {
        optimized.push(event)
        if (event.type === 'message') {
          lastMessageEvent = event
        } else {
          lastMessageEvent = null
        }
      }
    }

    return optimized
  }

  private async transformStream<T, R>(
    stream: AsyncIterable<T>,
    transform: (item: T) => Promise<R[]>
  ): Promise<AsyncIterable<R>> {
    async function* transformedStream() {
      for await (const item of stream) {
        const results = await transform(item)
        for (const result of results) {
          yield result
        }
      }
    }

    return transformedStream()
  }

  // 获取统计信息
  getStats(): {
    bufferSize: number
    eventRate: number
    listenerCount: number
    uptime: number
  } {
    return {
      bufferSize: this.eventBuffer.length,
      eventRate: this.eventRate,
      listenerCount: this.listeners.size,
      uptime: Date.now() - this.lastEventTime.getTime()
    }
  }
}
```

### 2. 创建SSE适配器

创建`agent/streaming/sse-adapter.ts`:

```typescript
import { StreamProcessor, StreamEvent } from './stream-processor'
import { NextRequest, NextResponse } from 'next/server'

export interface SSEConfig {
  retryInterval?: number
  heartbeatInterval?: number
  maxReconnectAttempts?: number
  enableCompression?: boolean
  cors?: {
    origin: string | string[]
    credentials?: boolean
  }
}

export class SSEAdapter {
  private streamProcessor: StreamProcessor
  private config: SSEConfig
  private activeConnections: Map<string, SSEConnection> = new Map()

  constructor(streamProcessor: StreamProcessor, config: SSEConfig = {}) {
    this.streamProcessor = streamProcessor
    this.config = {
      retryInterval: 3000,
      heartbeatInterval: 30000,
      maxReconnectAttempts: 5,
      enableCompression: true,
      cors: {
        origin: '*',
        credentials: true
      },
      ...config
    }
  }

  // 创建SSE连接
  createConnection(request: NextRequest): SSEConnection {
    const connectionId = this.generateConnectionId()
    const connection = new SSEConnection(connectionId, request, this.config)

    // 设置事件处理器
    connection.onEvent = (event: StreamEvent) => {
      this.streamProcessor.sendEvent(event)
    }

    connection.onClose = () => {
      this.activeConnections.delete(connectionId)
    }

    // 添加连接到活跃列表
    this.activeConnections.set(connectionId, connection)

    return connection
  }

  // 处理SSE请求
  async handleRequest(request: NextRequest): Promise<NextResponse> {
    const connection = this.createConnection(request)

    // 创建响应
    const response = new NextResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': this.config.cors!.origin,
        'Access-Control-Allow-Credentials': this.config.cors!.credentials ? 'true' : 'false'
      }
    })

    // 设置流式响应
    const stream = new ReadableStream({
      start: (controller) => {
        connection.setController(controller)
        connection.start()
      },
      cancel: () => {
        connection.close()
      }
    })

    return new NextResponse(stream, {
      headers: response.headers
    })
  }

  // 广播事件到所有连接
  broadcast(event: StreamEvent): void {
    for (const connection of this.activeConnections.values()) {
      connection.sendEvent(event)
    }
  }

  // 关闭所有连接
  closeAllConnections(): void {
    for (const connection of this.activeConnections.values()) {
      connection.close()
    }
    this.activeConnections.clear()
  }

  // 获取连接统计
  getConnectionStats(): {
    totalConnections: number
    activeConnections: number
    averageConnectionTime: number
  } {
    const activeConnections = Array.from(this.activeConnections.values())
    const totalConnections = this.activeConnections.size
    const averageConnectionTime = activeConnections.reduce((sum, conn) =>
      sum + (Date.now() - conn.createdAt.getTime()), 0
    ) / totalConnections || 0

    return {
      totalConnections,
      activeConnections: totalConnections,
      averageConnectionTime
    }
  }

  private generateConnectionId(): string {
    return `sse_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
}

class SSEConnection {
  public id: string
  public createdAt: Date
  public onEvent?: (event: StreamEvent) => void
  public onClose?: () => void
  private request: NextRequest
  private config: SSEConfig
  private controller?: ReadableStreamDefaultController
  private heartbeatTimer?: NodeJS.Timeout
  private isActive: boolean = true

  constructor(id: string, request: NextRequest, config: SSEConfig) {
    this.id = id
    this.createdAt = new Date()
    this.request = request
    this.config = config
  }

  setController(controller: ReadableStreamDefaultController): void {
    this.controller = controller
  }

  start(): void {
    // 发送初始连接事件
    this.sendEvent({
      id: `${this.id}_connected`,
      type: 'status',
      data: { status: 'connected', connectionId: this.id },
      timestamp: new Date()
    })

    // 启动心跳
    this.startHeartbeat()
  }

  sendEvent(event: StreamEvent): void {
    if (!this.isActive || !this.controller) return

    try {
      const data = this.formatSSEEvent(event)
      this.controller.enqueue(new TextEncoder().encode(data))
    } catch (error) {
      console.error(`SSE send error for connection ${this.id}:`, error)
      this.close()
    }
  }

  close(): void {
    if (!this.isActive) return

    this.isActive = false

    // 清理心跳定时器
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = undefined
    }

    // 关闭控制器
    if (this.controller) {
      try {
        this.controller.close()
      } catch (error) {
        console.error(`Error closing controller for connection ${this.id}:`, error)
      }
    }

    // 通知关闭
    if (this.onClose) {
      this.onClose()
    }
  }

  private startHeartbeat(): void {
    if (this.config.heartbeatInterval) {
      this.heartbeatTimer = setInterval(() => {
        this.sendEvent({
          id: `${this.id}_heartbeat`,
          type: 'status',
          data: { type: 'heartbeat', timestamp: new Date() },
          timestamp: new Date()
        })
      }, this.config.heartbeatInterval)
    }
  }

  private formatSSEEvent(event: StreamEvent): string {
    let sse = `event: ${event.type}\n`
    sse += `id: ${event.id}\n`
    sse += `data: ${JSON.stringify(event.data)}\n`

    if (event.metadata) {
      sse += `metadata: ${JSON.stringify(event.metadata)}\n`
    }

    sse += `retry: ${this.config.retryInterval}\n\n`
    return sse
  }
}
```

### 3. 创建WebSocket适配器

创建`agent/streaming/websocket-adapter.ts`:

```typescript
import { StreamProcessor, StreamEvent } from './stream-processor'
import { WebSocketServer, WebSocket } from 'ws'

export interface WebSocketConfig {
  port?: number
  path?: string
  maxConnections?: number
  enableCompression?: boolean
  heartbeatInterval?: number
  messageSizeLimit?: number
}

export class WebSocketAdapter {
  private streamProcessor: StreamProcessor
  private config: WebSocketConfig
  private server?: WebSocketServer
  private connections: Map<string, WebSocketConnection> = new Map()

  constructor(streamProcessor: StreamProcessor, config: WebSocketConfig = {}) {
    this.streamProcessor = streamProcessor
    this.config = {
      port: 3001,
      path: '/ws',
      maxConnections: 100,
      enableCompression: true,
      heartbeatInterval: 30000,
      messageSizeLimit: 1024 * 1024, // 1MB
      ...config
    }
  }

  // 启动WebSocket服务器
  start(): void {
    this.server = new WebSocketServer({
      port: this.config.port,
      path: this.config.path,
      maxPayload: this.config.messageSizeLimit
    })

    this.server.on('connection', (ws, req) => {
      this.handleConnection(ws, req)
    })

    this.server.on('error', (error) => {
      console.error('WebSocket server error:', error)
    })

    console.log(`WebSocket server started on ws://localhost:${this.config.port}${this.config.path}`)
  }

  // 停止WebSocket服务器
  stop(): void {
    if (this.server) {
      this.server.close()
      this.connections.clear()
    }
  }

  // 处理新连接
  private handleConnection(ws: WebSocket, req: any): void {
    if (this.connections.size >= this.config.maxConnections!) {
      ws.close(1013, 'Server full')
      return
    }

    const connectionId = this.generateConnectionId()
    const connection = new WebSocketConnection(connectionId, ws, this.config)

    // 设置事件处理器
    connection.onMessage = (message: any) => {
      this.handleMessage(connectionId, message)
    }

    connection.onClose = () => {
      this.connections.delete(connectionId)
    }

    // 添加连接到活跃列表
    this.connections.set(connectionId, connection)

    // 发送连接确认
    connection.send({
      type: 'connected',
      data: { connectionId, timestamp: new Date() }
    })

    console.log(`WebSocket connection established: ${connectionId}`)
  }

  // 处理客户端消息
  private async handleMessage(connectionId: string, message: any): Promise<void> {
    const connection = this.connections.get(connectionId)
    if (!connection) return

    try {
      const parsed = JSON.parse(message.toString())

      switch (parsed.type) {
        case 'chat':
          // 处理聊天消息
          await this.handleChatMessage(connectionId, parsed.data)
          break

        case 'action':
          // 处理UI动作
          await this.handleActionMessage(connectionId, parsed.data)
          break

        case 'ping':
          // 响应ping
          connection.send({ type: 'pong', timestamp: new Date() })
          break

        default:
          console.warn(`Unknown message type: ${parsed.type}`)
      }
    } catch (error) {
      console.error(`Error handling message from ${connectionId}:`, error)
      connection.send({
        type: 'error',
        data: { message: 'Invalid message format' }
      })
    }
  }

  // 处理聊天消息
  private async handleChatMessage(connectionId: string, data: any): Promise<void> {
    const connection = this.connections.get(connectionId)
    if (!connection) return

    // 发送处理中状态
    connection.send({
      type: 'status',
      data: { status: 'processing', messageId: data.messageId }
    })

    // 这里应该调用LangGraph工作流处理消息
    // 简化的处理示例：
    try {
      // 模拟处理延迟
      await new Promise(resolve => setTimeout(resolve, 1000))

      connection.send({
        type: 'message',
        data: {
          role: 'assistant',
          content: `收到您的消息: ${data.content}`,
          messageId: data.messageId
        }
      })
    } catch (error) {
      connection.send({
        type: 'error',
        data: { message: '处理消息时发生错误' }
      })
    }
  }

  // 处理UI动作消息
  private async handleActionMessage(connectionId: string, data: any): Promise<void> {
    const connection = this.connections.get(connectionId)
    if (!connection) return

    try {
      // 处理UI动作（如点击按钮、选择选项等）
      switch (data.action) {
        case 'retry':
          // 重试上一个操作
          break

        case 'cancel':
          // 取消当前操作
          break

        case 'refresh':
          // 刷新数据
          break

        default:
          console.warn(`Unknown action: ${data.action}`)
      }
    } catch (error) {
      connection.send({
        type: 'error',
        data: { message: '处理动作时发生错误' }
      })
    }
  }

  // 广播事件到所有连接
  broadcast(event: StreamEvent): void {
    for (const connection of this.connections.values()) {
      connection.send(event)
    }
  }

  // 发送事件到指定连接
  sendToConnection(connectionId: string, event: StreamEvent): void {
    const connection = this.connections.get(connectionId)
    if (connection) {
      connection.send(event)
    }
  }

  // 获取连接统计
  getStats(): {
    totalConnections: number
    activeConnections: number
    messagesReceived: number
    messagesSent: number
  } {
    let messagesReceived = 0
    let messagesSent = 0

    for (const connection of this.connections.values()) {
      messagesReceived += connection.stats.messagesReceived
      messagesSent += connection.stats.messagesSent
    }

    return {
      totalConnections: this.connections.size,
      activeConnections: this.connections.size,
      messagesReceived,
      messagesSent
    }
  }

  private generateConnectionId(): string {
    return `ws_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
}

class WebSocketConnection {
  public id: string
  private ws: WebSocket
  private config: WebSocketConfig
  private heartbeatTimer?: NodeJS.Timeout
  public onMessage?: (message: any) => void
  public onClose?: () => void
  public stats = {
    messagesReceived: 0,
    messagesSent: 0,
    connectedAt: new Date()
  }

  constructor(id: string, ws: WebSocket, config: WebSocketConfig) {
    this.id = id
    this.ws = ws
    this.config = config

    this.setupEventHandlers()
    this.startHeartbeat()
  }

  private setupEventHandlers(): void {
    this.ws.on('message', (data) => {
      this.stats.messagesReceived++
      if (this.onMessage) {
        this.onMessage(data)
      }
    })

    this.ws.on('close', () => {
      this.close()
    })

    this.ws.on('error', (error) => {
      console.error(`WebSocket error for connection ${this.id}:`, error)
      this.close()
    })

    this.ws.on('pong', () => {
      // 收到pong响应，连接正常
    })
  }

  private startHeartbeat(): void {
    if (this.config.heartbeatInterval) {
      this.heartbeatTimer = setInterval(() => {
        if (this.ws.readyState === WebSocket.OPEN) {
          this.ws.ping()
        }
      }, this.config.heartbeatInterval)
    }
  }

  send(event: StreamEvent | any): void {
    if (this.ws.readyState !== WebSocket.OPEN) return

    try {
      const message = JSON.stringify(event)
      this.ws.send(message)
      this.stats.messagesSent++
    } catch (error) {
      console.error(`Error sending message to ${this.id}:`, error)
      this.close()
    }
  }

  close(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = undefined
    }

    if (this.ws.readyState === WebSocket.OPEN) {
      this.ws.close()
    }

    if (this.onClose) {
      this.onClose()
    }
  }
}
```

### 4. 创建流式UI管理器

创建`agent/streaming/ui-manager.ts`:

```typescript
import { StreamEvent } from './stream-processor'
import { TMSAgentState } from '../types/state-annotations'

export interface UIUpdate {
  component: string
  props: Record<string, any>
  action?: string
  metadata?: Record<string, any>
}

export interface UIManagerConfig {
  enableAnimation?: boolean
  animationDuration?: number
  enableOptimization?: boolean
  debounceTime?: number
  throttleTime?: number
}

export class StreamingUIManager {
  private config: UIManagerConfig
  private pendingUpdates: Map<string, UIUpdate[]> = new Map()
  private debounceTimers: Map<string, NodeJS.Timeout> = new Map()
  private updateCallbacks: Map<string, (updates: UIUpdate[]) => void> = new Map()

  constructor(config: UIManagerConfig = {}) {
    this.config = {
      enableAnimation: true,
      animationDuration: 300,
      enableOptimization: true,
      debounceTime: 100,
      throttleTime: 50,
      ...config
    }
  }

  // 处理流式UI更新
  processStreamEvent(event: StreamEvent): UIUpdate | null {
    if (event.type !== 'ui_update') return null

    const { component, props } = event.data

    // 优化UI更新
    const optimizedUpdate = this.optimizeUIUpdate({
      component,
      props,
      metadata: event.metadata
    })

    return optimizedUpdate
  }

  // 批量处理UI更新
  processBatchEvents(events: StreamEvent[]): UIUpdate[] {
    const updates: UIUpdate[] = []

    // 按组件分组更新
    const componentUpdates = new Map<string, any[]>()

    for (const event of events) {
      if (event.type === 'ui_update') {
        const { component, props } = event.data
        if (!componentUpdates.has(component)) {
          componentUpdates.set(component, [])
        }
        componentUpdates.get(component)!.push(props)
      }
    }

    // 合并同一组件的更新
    for (const [component, propsList] of componentUpdates) {
      const mergedProps = this.mergeProps(propsList)
      updates.push({
        component,
        props: mergedProps,
        metadata: { source: 'batch', timestamp: new Date() }
      })
    }

    return updates
  }

  // 添加UI更新回调
  addUpdateCallback(componentId: string, callback: (updates: UIUpdate[]) => void): void {
    this.updateCallbacks.set(componentId, callback)
  }

  // 移除UI更新回调
  removeUpdateCallback(componentId: string): void {
    this.updateCallbacks.delete(componentId)
  }

  // 应用UI更新
  applyUpdate(update: UIUpdate): void {
    if (this.config.enableOptimization) {
      this.queueUpdate(update.component, update)
    } else {
      this.immediateApplyUpdate([update])
    }
  }

  // 获取待处理的更新
  getPendingUpdates(componentId?: string): UIUpdate[] {
    if (componentId) {
      return this.pendingUpdates.get(componentId) || []
    }
    return Array.from(this.pendingUpdates.values()).flat()
  }

  // 清理待处理的更新
  clearPendingUpdates(componentId?: string): void {
    if (componentId) {
      this.pendingUpdates.delete(componentId)
      const timer = this.debounceTimers.get(componentId)
      if (timer) {
        clearTimeout(timer)
        this.debounceTimers.delete(componentId)
      }
    } else {
      this.pendingUpdates.clear()
      this.debounceTimers.clear()
    }
  }

  // 队列更新（防抖处理）
  private queueUpdate(componentId: string, update: UIUpdate): void {
    if (!this.pendingUpdates.has(componentId)) {
      this.pendingUpdates.set(componentId, [])
    }

    this.pendingUpdates.get(componentId)!.push(update)

    // 清除之前的定时器
    const existingTimer = this.debounceTimers.get(componentId)
    if (existingTimer) {
      clearTimeout(existingTimer)
    }

    // 设置新的防抖定时器
    const timer = setTimeout(() => {
      this.flushUpdates(componentId)
    }, this.config.debounceTime)

    this.debounceTimers.set(componentId, timer)
  }

  // 刷新指定组件的更新
  private flushUpdates(componentId: string): void {
    const updates = this.pendingUpdates.get(componentId)
    if (updates && updates.length > 0) {
      this.immediateApplyUpdate(updates)
      this.pendingUpdates.delete(componentId)
    }
    this.debounceTimers.delete(componentId)
  }

  // 立即应用更新
  private immediateApplyUpdate(updates: UIUpdate[]): void {
    const callback = this.updateCallbacks.get(updates[0].component)
    if (callback) {
      callback(updates)
    }
  }

  // 优化UI更新
  private optimizeUIUpdate(update: UIUpdate): UIUpdate {
    // 深度拷贝props以避免引用问题
    const optimizedProps = JSON.parse(JSON.stringify(update.props))

    // 应用优化策略
    if (this.config.enableAnimation) {
      // 添加动画相关的props
      optimizedProps.animation = {
        duration: this.config.animationDuration,
        easing: 'ease-in-out'
      }
    }

    return {
      ...update,
      props: optimizedProps,
      metadata: {
        ...update.metadata,
        optimized: true,
        timestamp: new Date()
      }
    }
  }

  // 合并props
  private mergeProps(propsList: any[]): any {
    if (propsList.length === 1) {
      return propsList[0]
    }

    const merged = {}
    for (const props of propsList) {
      Object.assign(merged, props)
    }

    return merged
  }

  // 获取统计信息
  getStats(): {
    pendingUpdates: number
    activeCallbacks: number
    debounceTimers: number
  } {
    return {
      pendingUpdates: Array.from(this.pendingUpdates.values()).reduce(
        (sum, updates) => sum + updates.length, 0
      ),
      activeCallbacks: this.updateCallbacks.size,
      debounceTimers: this.debounceTimers.size
    }
  }
}

// React Hook for streaming UI updates
export function useStreamingUI(
  componentId: string,
  initialProps: Record<string, any> = {}
): {
  props: Record<string, any>
  loading: boolean
  error: string | null
  applyUpdate: (update: UIUpdate) => void
} {
  // 这个函数将在React组件中使用
  // 返回状态更新逻辑
  return {
    props: initialProps,
    loading: false,
    error: null,
    applyUpdate: (update: UIUpdate) => {
      console.log(`Applying update to ${componentId}:`, update)
    }
  }
}
```

### 5. 创建API路由

创建`app/api/chat/stream/route.ts`:

```typescript
import { StreamProcessor } from '@/agent/streaming/stream-processor'
import { SSEAdapter } from '@/agent/streaming/sse-adapter'
import { TMSWorkflow, WorkflowFactory } from '@/agent/graph'
import { ChatOpenAI } from '@langchain/openai'
import { NextRequest } from 'next/server'

// 创建全局实例
const streamProcessor = new StreamProcessor({
  enableBuffering: true,
  bufferSize: 5,
  flushInterval: 100,
  maxEventRate: 50
})

const sseAdapter = new SSEAdapter(streamProcessor)

const workflow = WorkflowFactory.createWithDefaults()
const executor = new WorkflowExecutor(workflow)

export async function GET(request: NextRequest) {
  return sseAdapter.handleRequest(request)
}

export async function POST(request: NextRequest) {
  try {
    const { messages, sessionId, userRole = 'customer' } = await request.json()

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return new NextResponse(
        JSON.stringify({ error: 'Invalid messages format' }),
        { status: 400 }
      )
    }

    // 准备初始状态
    const initialState = {
      messages: messages.map(msg => ({
        role: msg.role,
        content: msg.content,
        timestamp: new Date(msg.createdAt || Date.now())
      })),
      context: {
        userRole,
        currentTask: '',
        taskHistory: [],
        intent: '',
        entities: {},
        session: {
          id: sessionId || `session_${Date.now()}`,
          startTime: new Date(),
          lastActivity: new Date(),
          metadata: {}
        }
      },
      data: {
        orders: [],
        vehicles: [],
        dispatch: null,
        tracking: [],
        pod: null,
        customers: [],
        results: {},
        cache: {}
      },
      ui: {
        component: '',
        props: {},
        layout: 'vertical',
        actions: [],
        loading: false,
        error: '',
        timestamp: new Date()
      },
      metadata: {
        startTime: new Date(),
        stepCount: 0,
        toolCalls: [],
        errors: [],
        performance: {
          totalTime: 0,
          toolExecutionTime: 0,
          llmCalls: 0,
          tokenUsage: { prompt: 0, completion: 0, total: 0 },
          memoryUsage: { used: 0, total: 0, percentage: 0 }
        },
        checkpoint: {
          id: '',
          timestamp: new Date(),
          version: '1.0.0'
        }
      }
    }

    // 创建SSE连接
    const connection = sseAdapter.createConnection(request)

    // 设置事件处理器
    connection.onEvent = async (event: StreamEvent) => {
      // 处理流式事件
      console.log('Stream event:', event)
    }

    // 启动工作流执行
    const executeWorkflow = async () => {
      try {
        // 流式执行工作流
        const stream = await executor.streamExecute(initialState)

        for await (const step of stream) {
          // 转换步骤为流式事件
          const event: StreamEvent = {
            id: `${connection.id}_step_${step.step}`,
            type: 'status',
            data: {
              step: step.step,
              node: step.node,
              duration: step.duration,
              state: step.output
            },
            timestamp: step.timestamp
          }

          await streamProcessor.sendEvent(event)
        }

        // 发送完成事件
        await streamProcessor.sendEvent({
          id: `${connection.id}_complete`,
          type: 'complete',
          data: { status: 'completed', timestamp: new Date() },
          timestamp: new Date()
        })

      } catch (error) {
        console.error('Workflow execution error:', error)

        // 发送错误事件
        await streamProcessor.sendEvent({
          id: `${connection.id}_error`,
          type: 'error',
          data: {
            message: error.message,
            stack: error.stack
          },
          timestamp: new Date()
        })
      }
    }

    // 异步执行工作流
    executeWorkflow().catch(console.error)

    // 返回SSE响应
    return sseAdapter.handleRequest(request)

  } catch (error) {
    console.error('Chat stream API error:', error)
    return new NextResponse(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500 }
    )
  }
}
```

### 6. 创建导出文件

创建`agent/streaming/index.ts`:

```typescript
export {
  StreamProcessor,
  type StreamEvent,
  type StreamProcessorConfig
} from './stream-processor'

export {
  SSEAdapter,
  type SSEConfig
} from './sse-adapter'

export {
  WebSocketAdapter,
  type WebSocketConfig
} from './websocket-adapter'

export {
  StreamingUIManager,
  useStreamingUI,
  type UIUpdate,
  type UIManagerConfig
} from './ui-manager'

// 创建默认实例
export function createDefaultStreamProcessor(): StreamProcessor {
  return new StreamProcessor({
    enableBuffering: true,
    bufferSize: 10,
    flushInterval: 100,
    maxEventRate: 100,
    enableRetry: true
  })
}

export function createDefaultSSEAdapter(
  streamProcessor?: StreamProcessor
): SSEAdapter {
  return new SSEAdapter(streamProcessor || createDefaultStreamProcessor())
}

export function createDefaultWebSocketAdapter(
  streamProcessor?: StreamProcessor
): WebSocketAdapter {
  return new WebSocketAdapter(streamProcessor || createDefaultStreamProcessor())
}

export function createDefaultUIManager(): StreamingUIManager {
  return new StreamingUIManager({
    enableAnimation: true,
    animationDuration: 300,
    enableOptimization: true,
    debounceTime: 100,
    throttleTime: 50
  })
}
```

## 验证清单

- [ ] 流式处理器功能完整
- [ ] SSE适配器工作正常
- [ ] WebSocket适配器工作正常
- [ ] UI管理器优化有效
- [ ] API路由实现正确
- [ ] 性能优化机制可用
- [ ] 错误处理和恢复完善
- [ ] 连接管理稳定
- [ ] 单元测试覆盖率达到80%以上
- [ ] 集成测试通过

## 测试命令

```bash
# 流式处理器测试
npm test -- agent/streaming/stream-processor

# SSE适配器测试
npm test -- agent/streaming/sse-adapter

# WebSocket适配器测试
npm test -- agent/streaming/websocket-adapter

# UI管理器测试
npm test -- agent/streaming/ui-manager

# 端到端流式测试
npm run test:integration

# 性能测试
npm run test:performance
```

## 注意事项

- 流式处理需要注意内存使用和垃圾回收
- SSE和WebSocket连接需要正确管理生命周期
- UI更新需要考虑用户体验和性能平衡
- 错误处理需要提供友好的用户反馈
- 需要处理网络中断和重连机制

## 下一步

完成本任务后，将进行任务029: Agent测试和调试工具，为整个智能代理系统提供完整的测试、调试和监控能力。