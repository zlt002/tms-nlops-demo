---
title: "TMS NL-Ops演示系统任务012: 在途跟踪API实现"
epic: "tms-nlops-demo"
task: "012"
phase: "2"
status: completed
priority: "high"
estimated_hours: 3
parallel: true
depends_on: ["001", "002", "003", "004", "005", "006", "007"]
tags: ["api", "tracking", "location", "backend", "typescript"]
created: "2025-09-20T04:20:45Z"
updated: "2025-09-20T08:25:00Z"
---

## 概述

实现在途跟踪相关的API接口，包括位置上报、轨迹查询和实时监控。构建完整的运输跟踪系统，支持实时位置更新和历史轨迹回放。

## 目标

- 实现位置上报API接口
- 创建跟踪数据模型和类型定义
- 实现轨迹查询功能
- 集成实时监控功能
- 提供跟踪统计和分析功能

## 技术栈

- **框架**: Next.js 15+ API Routes
- **语言**: TypeScript
- **数据库**: PostgreSQL (通过Prisma)
- **验证**: Zod schema validation
- **地理信息**: 坐标系统和距离计算
- **API**: RESTful设计模式

## 实施步骤

### 1. 创建跟踪数据模型

更新`prisma/schema.prisma`:

```prisma
model TrackingLog {
  id          String   @id @default(cuid())
  shipmentId  String
  shipment    Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade)

  // 位置信息
  latitude    Float
  longitude   Float
  address     String?
  altitude    Float?   // 海拔高度(米)
  accuracy    Float?   // GPS精度(米)
  speed       Float    @default(0) // 速度(km/h)
  heading     Float    @default(0) // 方向(度)

  // 状态信息
  status      TrackingStatus @default(NORMAL)
  event       TrackingEvent?
  description String?  // 事件描述

  // 设备信息
  deviceId    String?  // 设备ID
  signalStrength Int?  // 信号强度
  batteryLevel Float?  // 电池电量百分比

  // 环境信息
  temperature Float?   // 温度(摄氏度)
  humidity    Float?   // 湿度百分比

  // 时间信息
  timestamp   DateTime @default(now())
  receivedAt  DateTime @default(now()) // 服务器接收时间

  // 元数据
  notes       String?
  verified    Boolean  @default(false) // 是否已验证
  createdBy   String?
  createdAt   DateTime @default(now())
}

model TrackingAlert {
  id          String   @id @default(cuid())
  shipmentId  String
  shipment    Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade)

  // 警报信息
  alertType   AlertType
  severity    AlertSeverity
  title       String
  description String
  location    String?  // JSON格式 {lat, lng, address}

  // 状态信息
  status      AlertStatus @default(ACTIVE)
  acknowledgedBy String?
  acknowledgedAt DateTime?

  // 时间信息
  triggeredAt DateTime @default(now())
  resolvedAt  DateTime?

  // 处理信息
  actionTaken String?
  resolution  String?
  notes       String?

  // 关联信息
  trackingLogId String?
  trackingLog TrackingLog? @relation(fields: [trackingLogId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model TrackingRoute {
  id          String   @id @default(cuid())
  shipmentId  String   @unique
  shipment    Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade)

  // 路线信息
  plannedRoute String  // JSON格式，包含路线点
  actualRoute  String? // JSON格式，实际行驶路线
  distance     Float   // 距离(公里)
  duration     Float   // 预计时间(分钟)

  // 统计信息
  totalDistance Float? // 实际总距离
  totalDuration Float? // 实际总时间
  avgSpeed      Float? // 平均速度
  maxSpeed      Float? // 最高速度
  fuelUsed      Float? // 燃油消耗
  stops         Int     @default(0) // 停车次数
  idleTime      Float   @default(0) // 怠速时间(分钟)

  // 路线状态
  status       RouteStatus @default(PLANNED)
  deviation    Float    @default(0) // 偏差百分比
  isOptimal    Boolean  @default(true) // 是否最优路线

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // 关联关系
  checkpoints  TrackingCheckpoint[]
}

model TrackingCheckpoint {
  id          String   @id @default(cuid())
  routeId     String
  route       TrackingRoute @relation(fields: [routeId], references: [id], onDelete: Cascade)

  // 检查点信息
  name        String
  type        CheckpointType
  address     String
  coordinates String   // JSON格式 {lat, lng}
  radius      Float    @default(100) // 半径(米)

  // 时间信息
  estimatedTime DateTime? // 预计到达时间
  actualTime    DateTime? // 实际到达时间
  duration      Float?    // 停留时间(分钟)

  // 状态信息
  status       CheckpointStatus @default(PENDING)
  isPassed     Boolean  @default(false)
  isRequired   Boolean  @default(true)

  // 统计信息
  visitCount   Int      @default(0)
  avgDuration  Float?   // 平均停留时间

  notes        String?
  order        Int      // 顺序
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

enum TrackingStatus {
  NORMAL         // 正常
  SPEEDING       // 超速
  IDLING         // 怠速
  STOPPED        // 停车
  OFF_ROUTE      // 偏离路线
  LOW_BATTERY    // 低电量
  NO_SIGNAL      // 无信号
  EMERGENCY      // 紧急情况
  MAINTENANCE    // 维护中
}

enum TrackingEvent {
  DEPARTURE      // 出发
  ARRIVAL        // 到达
  STOP           // 停车
  RESUME         // 恢复行驶
  FUEL_REFILL    // 加油
  REST_BREAK     // 休息
  DELAY          // 延迟
  ACCIDENT       // 事故
  BREAKDOWN      // 故障
  WEATHER_DELAY  // 天气延迟
  TRAFFIC_DELAY  // 交通拥堵
}

enum AlertType {
  GEOFENCE       // 地理围栏
  SPEEDING       // 超速
  IDLING         // 长时间怠速
  DEVIATION      // 路线偏离
  DELAY          // 延迟
  EMERGENCY      // 紧急情况
  LOW_FUEL       // 低燃油
  MAINTENANCE    // 维护提醒
  SCHEDULE       // 计划异常
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AlertStatus {
  ACTIVE         // 活跃
  ACKNOWLEDGED    // 已确认
  RESOLVED       // 已解决
  DISMISSED      // 已忽略
}

enum RouteStatus {
  PLANNED        // 已规划
  ACTIVE         // 进行中
  COMPLETED      // 已完成
  CANCELLED      // 已取消
  MODIFIED       // 已修改
}

enum CheckpointType {
  WAYPOINT       // 途经点
  STOP           // 停车点
  REST           // 休息点
  FUEL           // 加油点
  CHECK          // 检查点
  DELIVERY       // 交付点
}

enum CheckpointStatus {
  PENDING        // 待到达
  APPROACHING    // 接近中
  ARRIVED        // 已到达
  PASSED         // 已通过
  MISSED         // 已错过
  SKIPPED        // 已跳过
}
```

### 2. 创建跟踪类型定义

创建`src/types/tracking.ts`:

```typescript
import {
  TrackingStatus,
  TrackingEvent,
  AlertType,
  AlertSeverity,
  AlertStatus,
  RouteStatus,
  CheckpointType,
  CheckpointStatus
} from '@prisma/client'

export interface TrackingLog {
  id: string
  shipmentId: string
  latitude: number
  longitude: number
  address?: string
  altitude?: number
  accuracy?: number
  speed: number
  heading: number
  status: TrackingStatus
  event?: TrackingEvent
  description?: string
  deviceId?: string
  signalStrength?: number
  batteryLevel?: number
  temperature?: number
  humidity?: number
  timestamp: Date
  receivedAt: Date
  notes?: string
  verified: boolean
  createdBy?: string
  createdAt: Date
}

export interface TrackingAlert {
  id: string
  shipmentId: string
  alertType: AlertType
  severity: AlertSeverity
  title: string
  description: string
  location?: string
  status: AlertStatus
  acknowledgedBy?: string
  acknowledgedAt?: Date
  triggeredAt: Date
  resolvedAt?: Date
  actionTaken?: string
  resolution?: string
  notes?: string
  trackingLogId?: string
  createdAt: Date
  updatedAt: Date
}

export interface TrackingRoute {
  id: string
  shipmentId: string
  plannedRoute: string
  actualRoute?: string
  distance: number
  duration: number
  totalDistance?: number
  totalDuration?: number
  avgSpeed?: number
  maxSpeed?: number
  fuelUsed?: number
  stops: number
  idleTime: number
  status: RouteStatus
  deviation: number
  isOptimal: boolean
  createdAt: Date
  updatedAt: Date
  checkpoints?: TrackingCheckpoint[]
}

export interface TrackingCheckpoint {
  id: string
  routeId: string
  name: string
  type: CheckpointType
  address: string
  coordinates: string
  radius: number
  estimatedTime?: Date
  actualTime?: Date
  duration?: number
  status: CheckpointStatus
  isPassed: boolean
  isRequired: boolean
  visitCount: number
  avgDuration?: number
  notes?: string
  order: number
  createdAt: Date
  updatedAt: Date
}

export interface CreateTrackingLogRequest {
  shipmentId: string
  latitude: number
  longitude: number
  address?: string
  altitude?: number
  accuracy?: number
  speed?: number
  heading?: number
  status?: TrackingStatus
  event?: TrackingEvent
  description?: string
  deviceId?: string
  signalStrength?: number
  batteryLevel?: number
  temperature?: number
  humidity?: number
  timestamp?: Date
  notes?: string
}

export interface CreateTrackingAlertRequest {
  shipmentId: string
  alertType: AlertType
  severity: AlertSeverity
  title: string
  description: string
  location?: string
  trackingLogId?: string
  notes?: string
}

export interface TrackingQueryParams {
  shipmentId?: string
  status?: TrackingStatus
  event?: TrackingEvent
  startDate?: Date
  endDate?: Date
  deviceId?: string
  page?: number
  limit?: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
}

export interface AlertQueryParams {
  shipmentId?: string
  alertType?: AlertType
  severity?: AlertSeverity
  status?: AlertStatus
  startDate?: Date
  endDate?: Date
  page?: number
  limit?: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
}
```

### 3. 创建跟踪验证Schema

创建`src/validations/tracking.ts`:

```typescript
import { z } from 'zod'
import {
  TrackingStatus,
  TrackingEvent,
  AlertType,
  AlertSeverity,
  RouteStatus,
  CheckpointType,
  CheckpointStatus
} from '@prisma/client'

const coordinatesSchema = z.object({
  lat: z.number().min(-90).max(90),
  lng: z.number().min(-180).max(180),
  address: z.string().optional()
})

export const createTrackingLogSchema = z.object({
  shipmentId: z.string().min(1, '运单ID不能为空'),
  latitude: z.number().min(-90).max(90, '纬度必须在-90到90之间'),
  longitude: z.number().min(-180).max(180, '经度必须在-180到180之间'),
  address: z.string().optional(),
  altitude: z.number().optional(),
  accuracy: z.number().positive('GPS精度必须大于0').optional(),
  speed: z.number().min(0).max(300, '速度必须在0-300之间').default(0),
  heading: z.number().min(0).max(360, '方向必须在0-360度之间').default(0),
  status: z.nativeEnum(TrackingStatus).default(TrackingStatus.NORMAL),
  event: z.nativeEnum(TrackingEvent).optional(),
  description: z.string().optional(),
  deviceId: z.string().optional(),
  signalStrength: z.number().min(-100).max(0, '信号强度必须在-100到0之间').optional(),
  batteryLevel: z.number().min(0).max(100, '电池电量必须在0-100之间').optional(),
  temperature: z.number().optional(),
  humidity: z.number().min(0).max(100, '湿度必须在0-100之间').optional(),
  timestamp: z.date().optional(),
  notes: z.string().optional()
})

export const createTrackingAlertSchema = z.object({
  shipmentId: z.string().min(1, '运单ID不能为空'),
  alertType: z.nativeEnum(AlertType),
  severity: z.nativeEnum(AlertSeverity),
  title: z.string().min(1, '警报标题不能为空'),
  description: z.string().min(1, '警报描述不能为空'),
  location: z.string().refine(val => {
    if (!val) return true
    try {
      const coords = JSON.parse(val)
      return coordinatesSchema.safeParse(coords).success
    } catch {
      return false
    }
  }, '位置格式不正确').optional(),
  trackingLogId: z.string().optional(),
  notes: z.string().optional()
})

export const trackingQuerySchema = z.object({
  shipmentId: z.string().optional(),
  status: z.nativeEnum(TrackingStatus).optional(),
  event: z.nativeEnum(TrackingEvent).optional(),
  startDate: z.date().optional(),
  endDate: z.date().optional(),
  deviceId: z.string().optional(),
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(1000).default(100),
  sortBy: z.string().default('timestamp'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
})

export const alertQuerySchema = z.object({
  shipmentId: z.string().optional(),
  alertType: z.nativeEnum(AlertType).optional(),
  severity: z.nativeEnum(AlertSeverity).optional(),
  status: z.nativeEnum(AlertStatus).optional(),
  startDate: z.date().optional(),
  endDate: z.date().optional(),
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
  sortBy: z.string().default('triggeredAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
})

export const createRouteSchema = z.object({
  shipmentId: z.string().min(1, '运单ID不能为空'),
  plannedRoute: z.string().min(1, '计划路线不能为空'),
  distance: z.number().positive('距离必须大于0'),
  duration: z.number().positive('时间必须大于0'),
  checkpoints: z.array(z.object({
    name: z.string().min(1, '检查点名称不能为空'),
    type: z.nativeEnum(CheckpointType),
    address: z.string().min(1, '检查点地址不能为空'),
    coordinates: z.string().refine(val => {
      try {
        const coords = JSON.parse(val)
        return coordinatesSchema.safeParse(coords).success
      } catch {
        return false
      }
    }, '坐标格式不正确'),
    radius: z.number().positive('半径必须大于0').default(100),
    estimatedTime: z.date().optional(),
    isRequired: z.boolean().default(true),
    notes: z.string().optional(),
    order: z.number().min(0, '顺序不能为负数')
  })).optional()
})
```

### 4. 实现位置上报API

创建`src/app/api/tracking/logs/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { createTrackingLogSchema, trackingQuerySchema } from '@/validations/tracking'
import { TrackingService } from '@/services/trackingService'

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const query = {
      shipmentId: searchParams.get('shipmentId') || undefined,
      status: searchParams.get('status') || undefined,
      event: searchParams.get('event') || undefined,
      startDate: searchParams.get('startDate') ? new Date(searchParams.get('startDate')!) : undefined,
      endDate: searchParams.get('endDate') ? new Date(searchParams.get('endDate')!) : undefined,
      deviceId: searchParams.get('deviceId') || undefined,
      page: parseInt(searchParams.get('page') || '1'),
      limit: parseInt(searchParams.get('limit') || '100'),
      sortBy: searchParams.get('sortBy') || 'timestamp',
      sortOrder: (searchParams.get('sortOrder') as 'asc' | 'desc') || 'desc'
    }

    const validatedQuery = trackingQuerySchema.parse(query)

    const where: any = {}
    if (validatedQuery.shipmentId) where.shipmentId = validatedQuery.shipmentId
    if (validatedQuery.status) where.status = validatedQuery.status
    if (validatedQuery.event) where.event = validatedQuery.event
    if (validatedQuery.deviceId) where.deviceId = validatedQuery.deviceId
    if (validatedQuery.startDate || validatedQuery.endDate) {
      where.timestamp = {}
      if (validatedQuery.startDate) where.timestamp.gte = validatedQuery.startDate
      if (validatedQuery.endDate) where.timestamp.lte = validatedQuery.endDate
    }

    const [logs, total] = await Promise.all([
      prisma.trackingLog.findMany({
        where,
        include: {
          shipment: {
            select: {
              id: true,
              shipmentNumber: true,
              status: true,
              originAddress: true,
              destinationAddress: true
            }
          }
        },
        skip: (validatedQuery.page - 1) * validatedQuery.limit,
        take: validatedQuery.limit,
        orderBy: {
          [validatedQuery.sortBy]: validatedQuery.sortOrder
        }
      }),
      prisma.trackingLog.count({ where })
    ])

    return NextResponse.json({
      success: true,
      data: logs,
      pagination: {
        page: validatedQuery.page,
        limit: validatedQuery.limit,
        total,
        pages: Math.ceil(total / validatedQuery.limit)
      }
    })
  } catch (error) {
    console.error('获取跟踪日志失败:', error)
    return NextResponse.json(
      { error: '获取跟踪日志失败', details: error.message },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const validatedData = createTrackingLogSchema.parse(body)

    // 检查运单是否存在
    const shipment = await prisma.shipment.findUnique({
      where: { id: validatedData.shipmentId },
      include: {
        vehicle: true,
        driver: true
      }
    })

    if (!shipment) {
      return NextResponse.json(
        { error: '运单不存在' },
        { status: 404 }
      )
    }

    // 验证运单状态
    if (shipment.status !== 'IN_TRANSIT' && shipment.status !== 'LOADING' && shipment.status !== 'UNLOADING') {
      return NextResponse.json(
        { error: '运单不在运输状态' },
        { status: 400 }
      )
    }

    // 使用提供的timestamp或当前时间
    const timestamp = validatedData.timestamp || new Date()

    // 创建跟踪日志
    const trackingLog = await prisma.trackingLog.create({
      data: {
        shipmentId: validatedData.shipmentId,
        latitude: validatedData.latitude,
        longitude: validatedData.longitude,
        address: validatedData.address,
        altitude: validatedData.altitude,
        accuracy: validatedData.accuracy,
        speed: validatedData.speed || 0,
        heading: validatedData.heading || 0,
        status: validatedData.status || TrackingStatus.NORMAL,
        event: validatedData.event,
        description: validatedData.description,
        deviceId: validatedData.deviceId,
        signalStrength: validatedData.signalStrength,
        batteryLevel: validatedData.batteryLevel,
        temperature: validatedData.temperature,
        humidity: validatedData.humidity,
        timestamp,
        receivedAt: new Date(),
        notes: validatedData.notes,
        createdBy: 'system' // 实际应用中应该是设备或用户ID
      }
    })

    // 更新运单的当前位置和进度
    await TrackingService.updateShipmentLocation(validatedData.shipmentId, {
      latitude: validatedData.latitude,
      longitude: validatedData.longitude,
      address: validatedData.address,
      speed: validatedData.speed || 0,
      timestamp
    })

    // 检查异常情况并生成警报
    await TrackingService.checkAndCreateAlerts(shipment, trackingLog)

    // 更新车辆位置
    if (shipment.vehicle) {
      await prisma.vehicleLocation.upsert({
        where: { vehicleId: shipment.vehicleId },
        update: {
          latitude: validatedData.latitude,
          longitude: validatedData.longitude,
          address: validatedData.address,
          speed: validatedData.speed || 0,
          heading: validatedData.heading || 0,
          timestamp
        },
        create: {
          vehicleId: shipment.vehicleId,
          latitude: validatedData.latitude,
          longitude: validatedData.longitude,
          address: validatedData.address,
          speed: validatedData.speed || 0,
          heading: validatedData.heading || 0,
          timestamp
        }
      })

      // 添加到车辆位置历史
      await prisma.vehicleLocationHistory.create({
        data: {
          vehicleId: shipment.vehicleId,
          latitude: validatedData.latitude,
          longitude: validatedData.longitude,
          address: validatedData.address,
          speed: validatedData.speed || 0,
          heading: validatedData.heading || 0,
          timestamp
        }
      })
    }

    return NextResponse.json({
      success: true,
      data: trackingLog,
      message: '位置上报成功'
    }, { status: 201 })
  } catch (error) {
    console.error('位置上报失败:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: '数据验证失败', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: '位置上报失败', details: error.message },
      { status: 500 }
    )
  }
}
```

### 5. 实现轨迹查询API

创建`src/app/api/tracking/routes/[shipmentId]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { TrackingService } from '@/services/trackingService'

export async function GET(
  request: NextRequest,
  { params }: { params: { shipmentId: string } }
) {
  try {
    const shipment = await prisma.shipment.findUnique({
      where: { id: params.shipmentId }
    })

    if (!shipment) {
      return NextResponse.json(
        { error: '运单不存在' },
        { status: 404 }
      )
    }

    // 获取完整的轨迹信息
    const trackingData = await TrackingService.getTrackingRoute(params.shipmentId)

    return NextResponse.json({
      success: true,
      data: trackingData
    })
  } catch (error) {
    console.error('获取轨迹信息失败:', error)
    return NextResponse.json(
      { error: '获取轨迹信息失败', details: error.message },
      { status: 500 }
    )
  }
}

export async function POST(
  request: NextRequest,
  { params }: { params: { shipmentId: string } }
) {
  try {
    const body = await request.json()
    const { plannedRoute, checkpoints } = body

    const shipment = await prisma.shipment.findUnique({
      where: { id: params.shipmentId }
    })

    if (!shipment) {
      return NextResponse.json(
        { error: '运单不存在' },
        { status: 404 }
      )
    }

    // 计算路线距离和时间
    const routeInfo = await TrackingService.calculateRouteInfo(plannedRoute)

    // 创建或更新路线
    const route = await prisma.trackingRoute.upsert({
      where: { shipmentId: params.shipmentId },
      update: {
        plannedRoute,
        distance: routeInfo.distance,
        duration: routeInfo.duration,
        status: RouteStatus.PLANNED
      },
      create: {
        shipmentId: params.shipmentId,
        plannedRoute,
        distance: routeInfo.distance,
        duration: routeInfo.duration,
        status: RouteStatus.PLANNED
      }
    })

    // 创建检查点
    if (checkpoints && checkpoints.length > 0) {
      await prisma.trackingCheckpoint.deleteMany({
        where: { routeId: route.id }
      })

      const checkpointData = checkpoints.map((checkpoint: any, index: number) => ({
        routeId: route.id,
        name: checkpoint.name,
        type: checkpoint.type,
        address: checkpoint.address,
        coordinates: checkpoint.coordinates,
        radius: checkpoint.radius || 100,
        estimatedTime: checkpoint.estimatedTime,
        isRequired: checkpoint.isRequired ?? true,
        notes: checkpoint.notes,
        order: index
      }))

      await prisma.trackingCheckpoint.createMany({
        data: checkpointData
      })
    }

    return NextResponse.json({
      success: true,
      data: {
        route,
        checkpoints: checkpoints || []
      },
      message: '路线创建成功'
    }, { status: 201 })
  } catch (error) {
    console.error('创建路线失败:', error)
    return NextResponse.json(
      { error: '创建路线失败', details: error.message },
      { status: 500 }
    )
  }
}
```

### 6. 实现警报管理API

创建`src/app/api/tracking/alerts/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { alertQuerySchema } from '@/validations/tracking'

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const query = {
      shipmentId: searchParams.get('shipmentId') || undefined,
      alertType: searchParams.get('alertType') || undefined,
      severity: searchParams.get('severity') || undefined,
      status: searchParams.get('status') || undefined,
      startDate: searchParams.get('startDate') ? new Date(searchParams.get('startDate')!) : undefined,
      endDate: searchParams.get('endDate') ? new Date(searchParams.get('endDate')!) : undefined,
      page: parseInt(searchParams.get('page') || '1'),
      limit: parseInt(searchParams.get('limit') || '20'),
      sortBy: searchParams.get('sortBy') || 'triggeredAt',
      sortOrder: (searchParams.get('sortOrder') as 'asc' | 'desc') || 'desc'
    }

    const validatedQuery = alertQuerySchema.parse(query)

    const where: any = {}
    if (validatedQuery.shipmentId) where.shipmentId = validatedQuery.shipmentId
    if (validatedQuery.alertType) where.alertType = validatedQuery.alertType
    if (validatedQuery.severity) where.severity = validatedQuery.severity
    if (validatedQuery.status) where.status = validatedQuery.status
    if (validatedQuery.startDate || validatedQuery.endDate) {
      where.triggeredAt = {}
      if (validatedQuery.startDate) where.triggeredAt.gte = validatedQuery.startDate
      if (validatedQuery.endDate) where.triggeredAt.lte = validatedQuery.endDate
    }

    const [alerts, total] = await Promise.all([
      prisma.trackingAlert.findMany({
        where,
        include: {
          shipment: {
            select: {
              id: true,
              shipmentNumber: true,
              status: true,
              originAddress: true,
              destinationAddress: true
            }
          },
          trackingLog: {
            select: {
              id: true,
              timestamp: true,
              latitude: true,
              longitude: true,
              speed: true
            }
          }
        },
        skip: (validatedQuery.page - 1) * validatedQuery.limit,
        take: validatedQuery.limit,
        orderBy: {
          [validatedQuery.sortBy]: validatedQuery.sortOrder
        }
      }),
      prisma.trackingAlert.count({ where })
    ])

    return NextResponse.json({
      success: true,
      data: alerts,
      pagination: {
        page: validatedQuery.page,
        limit: validatedQuery.limit,
        total,
        pages: Math.ceil(total / validatedQuery.limit)
      }
    })
  } catch (error) {
    console.error('获取警报列表失败:', error)
    return NextResponse.json(
      { error: '获取警报列表失败', details: error.message },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const validatedData = createTrackingAlertSchema.parse(body)

    // 检查运单是否存在
    const shipment = await prisma.shipment.findUnique({
      where: { id: validatedData.shipmentId }
    })

    if (!shipment) {
      return NextResponse.json(
        { error: '运单不存在' },
        { status: 404 }
      )
    }

    const alert = await prisma.trackingAlert.create({
      data: {
        shipmentId: validatedData.shipmentId,
        alertType: validatedData.alertType,
        severity: validatedData.severity,
        title: validatedData.title,
        description: validatedData.description,
        location: validatedData.location,
        trackingLogId: validatedData.trackingLogId,
        notes: validatedData.notes,
        status: AlertStatus.ACTIVE
      },
      include: {
        shipment: {
          select: {
            id: true,
            shipmentNumber: true,
            status: true
          }
        }
      }
    })

    // 发送通知（这里可以集成消息推送服务）
    await TrackingService.sendAlertNotification(alert)

    return NextResponse.json({
      success: true,
      data: alert,
      message: '警报创建成功'
    }, { status: 201 })
  } catch (error) {
    console.error('创建警报失败:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: '数据验证失败', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: '创建警报失败', details: error.message },
      { status: 500 }
    )
  }
}
```

### 7. 创建跟踪服务层

创建`src/services/trackingService.ts`:

```typescript
import { prisma } from '@/lib/prisma'
import {
  TrackingStatus,
  TrackingEvent,
  AlertType,
  AlertSeverity,
  RouteStatus
} from '@prisma/client'

export class TrackingService {
  static async updateShipmentLocation(shipmentId: string, location: any) {
    const shipment = await prisma.shipment.findUnique({
      where: { id: shipmentId },
      include: {
        route: true,
        checkpoints: true
      }
    })

    if (!shipment) return

    // 计算运输进度
    const progress = await this.calculateProgress(shipment, location)

    // 更新运单信息
    await prisma.shipment.update({
      where: { id: shipmentId },
      data: {
        currentLocation: location.address,
        currentCoordinates: JSON.stringify({
          lat: location.latitude,
          lng: location.longitude
        }),
        progress
      }
    })

    // 检查检查点
    await this.checkCheckpoints(shipment, location)

    // 更新路线统计
    if (shipment.route) {
      await this.updateRouteStats(shipment.route.id, location)
    }
  }

  static async calculateProgress(shipment: any, currentLocation: any): Promise<number> {
    try {
      const origin = JSON.parse(shipment.originCoordinates || '{}')
      const destination = JSON.parse(shipment.destinationCoordinates || '{}')

      const totalDistance = await this.calculateDistance(
        origin.lat, origin.lng,
        destination.lat, destination.lng
      )

      const remainingDistance = await this.calculateDistance(
        currentLocation.latitude, currentLocation.longitude,
        destination.lat, destination.lng
      )

      const progress = Math.max(0, Math.min(100, ((totalDistance - remainingDistance) / totalDistance) * 100))
      return Math.round(progress * 100) / 100
    } catch (error) {
      console.error('计算进度失败:', error)
      return 0
    }
  }

  static async checkAndCreateAlerts(shipment: any, trackingLog: any) {
    const alerts = []

    // 检查超速
    if (trackingLog.speed > 120) {
      alerts.push({
        shipmentId: shipment.id,
        alertType: AlertType.SPEEDING,
        severity: AlertSeverity.HIGH,
        title: '超速警报',
        description: `车辆速度达到 ${trackingLog.speed} km/h，超过限速`,
        location: JSON.stringify({
          lat: trackingLog.latitude,
          lng: trackingLog.longitude,
          address: trackingLog.address
        }),
        trackingLogId: trackingLog.id
      })
    }

    // 检查低电量
    if (trackingLog.batteryLevel && trackingLog.batteryLevel < 20) {
      alerts.push({
        shipmentId: shipment.id,
        alertType: AlertType.LOW_FUEL,
        severity: AlertSeverity.MEDIUM,
        title: '低电量警报',
        description: `设备电量仅剩 ${trackingLog.batteryLevel}%`,
        location: JSON.stringify({
          lat: trackingLog.latitude,
          lng: trackingLog.longitude,
          address: trackingLog.address
        }),
        trackingLogId: trackingLog.id
      })
    }

    // 检查路线偏离
    if (shipment.route) {
      const isOffRoute = await this.checkRouteDeviation(
        shipment.route,
        trackingLog.latitude,
        trackingLog.longitude
      )

      if (isOffRoute) {
        alerts.push({
          shipmentId: shipment.id,
          alertType: AlertType.DEVIATION,
          severity: AlertSeverity.MEDIUM,
          title: '路线偏离警报',
          description: '车辆偏离了预定路线',
          location: JSON.stringify({
            lat: trackingLog.latitude,
            lng: trackingLog.longitude,
            address: trackingLog.address
          }),
          trackingLogId: trackingLog.id
        })
      }
    }

    // 检查延迟
    if (shipment.estimatedArrival && new Date() > new Date(shipment.estimatedArrival)) {
      alerts.push({
        shipmentId: shipment.id,
        alertType: AlertType.DELAY,
        severity: AlertSeverity.MEDIUM,
        title: '运输延迟警报',
        description: '预计到达时间已过，运输可能延迟',
        location: JSON.stringify({
          lat: trackingLog.latitude,
          lng: trackingLog.longitude,
          address: trackingLog.address
        }),
        trackingLogId: trackingLog.id
      })
    }

    // 创建警报
    for (const alert of alerts) {
      try {
        await prisma.trackingAlert.create({
          data: alert
        })
        await this.sendAlertNotification(alert)
      } catch (error) {
        console.error('创建警报失败:', error)
      }
    }
  }

  static async getTrackingRoute(shipmentId: string) {
    const shipment = await prisma.shipment.findUnique({
      where: { id: shipmentId },
      include: {
        route: {
          include: {
            checkpoints: {
              orderBy: { order: 'asc' }
            }
          }
        }
      }
    })

    if (!shipment) {
      throw new Error('运单不存在')
    }

    // 获取最近的跟踪点
    const recentLogs = await prisma.trackingLog.findMany({
      where: { shipmentId },
      orderBy: { timestamp: 'desc' },
      take: 1000
    })

    const routeData = {
      shipment: {
        id: shipment.id,
        shipmentNumber: shipment.shipmentNumber,
        originAddress: shipment.originAddress,
        destinationAddress: shipment.destinationAddress,
        status: shipment.status,
        progress: shipment.progress
      },
      plannedRoute: shipment.route,
      actualRoute: recentLogs.reverse().map(log => ({
        latitude: log.latitude,
        longitude: log.longitude,
        address: log.address,
        timestamp: log.timestamp,
        speed: log.speed,
        status: log.status
      })),
      statistics: await this.calculateRouteStatistics(shipmentId)
    }

    return routeData
  }

  static async calculateRouteStatistics(shipmentId: string) {
    const logs = await prisma.trackingLog.findMany({
      where: { shipmentId },
      orderBy: { timestamp: 'asc' }
    })

    if (logs.length < 2) {
      return {
        totalDistance: 0,
        totalDuration: 0,
        avgSpeed: 0,
        maxSpeed: 0,
        stops: 0,
        idleTime: 0
      }
    }

    let totalDistance = 0
    let totalDuration = 0
    let maxSpeed = 0
    let speedSum = 0
    let stops = 0
    let idleTime = 0

    for (let i = 1; i < logs.length; i++) {
      const prevLog = logs[i - 1]
      const currentLog = logs[i]

      // 计算距离
      const distance = await this.calculateDistance(
        prevLog.latitude, prevLog.longitude,
        currentLog.latitude, currentLog.longitude
      )
      totalDistance += distance

      // 计算时间
      const timeDiff = currentLog.timestamp.getTime() - prevLog.timestamp.getTime()
      totalDuration += timeDiff

      // 速度统计
      if (currentLog.speed > maxSpeed) {
        maxSpeed = currentLog.speed
      }
      speedSum += currentLog.speed

      // 检查停车
      if (currentLog.speed === 0 && prevLog.speed === 0) {
        stops++
        idleTime += timeDiff / (1000 * 60) // 转换为分钟
      }
    }

    return {
      totalDistance: Math.round(totalDistance * 100) / 100,
      totalDuration: Math.round(totalDuration / (1000 * 60)), // 转换为分钟
      avgSpeed: Math.round((speedSum / logs.length) * 100) / 100,
      maxSpeed: Math.round(maxSpeed * 100) / 100,
      stops,
      idleTime: Math.round(idleTime * 100) / 100
    }
  }

  private static async calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): Promise<number> {
    // 使用Haversine公式计算两点间距离
    const R = 6371 // 地球半径(公里)
    const dLat = (lat2 - lat1) * Math.PI / 180
    const dLng = (lng2 - lng1) * Math.PI / 180
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2)
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
    return R * c
  }

  private static async checkRouteDeviation(route: any, lat: number, lng: number): Promise<boolean> {
    try {
      const plannedRoute = JSON.parse(route.plannedRoute)
      // 简化版偏离检查，实际应该使用更复杂的算法
      let minDistance = Infinity

      for (const point of plannedRoute) {
        const distance = await this.calculateDistance(
          lat, lng, point.lat, point.lng
        )
        minDistance = Math.min(minDistance, distance)
      }

      // 如果偏离超过500米，认为偏离路线
      return minDistance > 0.5
    } catch (error) {
      console.error('检查路线偏离失败:', error)
      return false
    }
  }

  private static async checkCheckpoints(shipment: any, location: any) {
    if (!shipment.checkpoints || shipment.checkpoints.length === 0) return

    for (const checkpoint of shipment.checkpoints) {
      if (checkpoint.status !== CheckpointStatus.PENDING) continue

      try {
        const checkpointCoords = JSON.parse(checkpoint.coordinates)
        const distance = await this.calculateDistance(
          location.latitude, location.longitude,
          checkpointCoords.lat, checkpointCoords.lng
        )

        if (distance <= checkpoint.radius / 1000) { // 转换为公里
          await prisma.trackingCheckpoint.update({
            where: { id: checkpoint.id },
            data: {
              status: CheckpointStatus.ARRIVED,
              actualTime: new Date(),
              visitCount: { increment: 1 }
            }
          })
        }
      } catch (error) {
        console.error('检查检查点失败:', error)
      }
    }
  }

  private static async updateRouteStats(routeId: string, location: any) {
    // 更新路线统计信息的实现
    // 这里可以根据实际需求添加更详细的统计逻辑
  }

  private static async sendAlertNotification(alert: any) {
    // 发送警报通知的实现
    // 这里可以集成邮件、短信、推送等通知服务
    console.log('发送警报通知:', alert)
  }

  static async calculateRouteInfo(route: any): Promise<{ distance: number; duration: number }> {
    // 简化版路线信息计算
    try {
      const points = JSON.parse(route)
      let totalDistance = 0

      for (let i = 1; i < points.length; i++) {
        const distance = await this.calculateDistance(
          points[i-1].lat, points[i-1].lng,
          points[i].lat, points[i].lng
        )
        totalDistance += distance
      }

      const avgSpeed = 60 // 假设平均时速60公里
      const duration = Math.ceil((totalDistance / avgSpeed) * 60) // 转换为分钟

      return {
        distance: Math.round(totalDistance * 100) / 100,
        duration
      }
    } catch (error) {
      console.error('计算路线信息失败:', error)
      return { distance: 0, duration: 0 }
    }
  }
}
```

## 验证清单

- [ ] 跟踪数据模型定义正确
- [ ] 位置上报API实现完整
- [ ] 轨迹查询功能正常
- [ ] 警报管理系统工作正常
- [ ] 检查点管理功能正常
- [ ] 路线统计功能准确
- [ ] 进度计算逻辑正确
- [ ] 偏离检测功能正常
- [ ] 数据验证Schema有效
- [ ] 错误处理机制完善

## 测试命令

```bash
# 运行API测试
npm run test:api

# 数据库迁移
npx prisma migrate dev

# 生成Prisma客户端
npx prisma generate
```

## 注意事项

- 确保位置数据的精度和有效性
- 距离计算需要考虑地球曲率
- 警报规则需要根据业务需求调整
- 检查点检测需要合适的半径设置
- 路线偏离检测需要合理的阈值
- 大量位置数据需要优化存储和查询性能
- 实时跟踪需要考虑数据传输频率