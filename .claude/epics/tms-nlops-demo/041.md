---
title: 演示数据准备和场景设计
epic: tms-nlops-demo
task_id: 041
type: task
status: todo
priority: high
tags: ["data", "demo", "scenarios", "testing", "content"]
assignee: ""
created: 2025-09-20T04:20:45Z
updated: 2025-09-20T04:20:45Z
parallel: false
depends_on: ["016", "017", "018", "019", "020", "021", "022", "023", "024", "025", "030", "031", "032", "033", "034", "035", "036", "037", "038", "039", "040"]
effort: 4
description: 准备演示数据和设计演示场景，支持系统功能和效果展示
---

## 任务描述

为TMS NL-Ops演示系统准备真实、丰富的演示数据，设计多样化的演示场景，确保能够全面展示系统的核心功能和用户体验对比效果。

## 详细需求

### 1. 演示数据准备
- **客户数据**: 不同类型和规模的客户信息
- **订单数据**: 各种状态和类型的运输订单
- **车辆数据**: 不同类型和状态的车辆信息
- **路线数据**: 常见运输路线和距离信息
- **历史数据**: 过往运输记录和统计数据

### 2. 场景设计
- **基础功能场景**: 订单管理、排车调度等基础功能
- **复杂业务场景**: 多订单合并、异常处理等复杂场景
- **对比演示场景**: 传统UI与AI操作的效率对比
- **性能测试场景**: 高并发和大数据量场景
- **用户引导场景**: 新用户上手和功能引导

### 3. 数据管理
- **数据生成**: 自动化生成真实测试数据
- **数据导入**: 批量导入演示数据
- **数据更新**: 定期更新和清理数据
- **数据验证**: 数据质量和一致性验证
- **数据备份**: 演示数据备份和恢复

### 4. 演示脚本
- **操作脚本**: 预定义的演示操作步骤
- **台词设计**: 演示讲解和说明内容
- **时间控制**: 演示节奏和时间安排
- **应急预案**: 演示异常情况处理
- **效果评估**: 演示效果和用户反馈收集

## 技术实现

### 演示数据生成
```typescript
// scripts/generate-demo-data.ts
import { PrismaClient } from '@prisma/client';
import { faker } from '@faker-js/faker/locale/zh_CN';

const prisma = new PrismaClient();

// 客户类型
const CUSTOMER_TYPES = ['科技', '制造', '零售', '物流', '电商', '医药', '食品'];
const CUSTOMER_SIZES = ['大型', '中型', '小型'];

// 车辆类型
const VEHICLE_TYPES = ['TRUCK', 'VAN', 'REFRIGERATED', 'FLATBED'] as const;
const VEHICLE_STATUSES = ['AVAILABLE', 'IN_TRANSIT', 'MAINTENANCE', 'OFFLINE'] as const;

// 城市和路线数据
const CITIES = [
  { name: '北京', lat: 39.9042, lng: 116.4074 },
  { name: '上海', lat: 31.2304, lng: 121.4737 },
  { name: '广州', lat: 23.1291, lng: 113.2644 },
  { name: '深圳', lat: 22.5431, lng: 114.0579 },
  { name: '杭州', lat: 30.2741, lng: 120.1551 },
  { name: '南京', lat: 32.0603, lng: 118.7969 },
  { name: '成都', lat: 30.5728, lng: 104.0668 },
  { name: '武汉', lat: 30.5928, lng: 114.3055 },
  { name: '西安', lat: 34.3416, lng: 108.9398 },
  { name: '重庆', lat: 29.5647, lng: 106.5507 }
];

// 货物类型
const GOODS_TYPES = [
  '电子产品', '服装', '食品', '建材', '机械设备',
  '医药用品', '汽车配件', '生鲜', '日用品', '化工产品'
];

// 订单状态分布
const ORDER_STATUS_WEIGHTS = [
  { status: 'PENDING', weight: 15 },
  { status: 'SCHEDULED', weight: 20 },
  { status: 'PICKED_UP', weight: 15 },
  { status: 'IN_TRANSIT', weight: 25 },
  { status: 'DELIVERED', weight: 20 },
  { status: 'CANCELLED', weight: 5 }
];

class DemoDataGenerator {
  private customers: any[] = [];
  private vehicles: any[] = [];
  private orders: any[] = [];

  async generateAll() {
    console.log('开始生成演示数据...');

    await this.generateCustomers();
    await this.generateVehicles();
    await this.generateOrders();
    await this.generateDispatches();
    await this.generateTracking();
    await this.generatePODs();

    console.log('演示数据生成完成!');
  }

  private async generateCustomers() {
    console.log('生成客户数据...');

    for (let i = 0; i < 50; i++) {
      const type = faker.helpers.arrayElement(CUSTOMER_TYPES);
      const size = faker.helpers.arrayElement(CUSTOMER_SIZES);

      const customer = await prisma.customer.create({
        data: {
          name: `${faker.company.name()}${type}公司`,
          phone: faker.phone.number('1##########'),
          email: faker.internet.email(),
          createdAt: faker.date.past({ years: 2 }),
          updatedAt: new Date()
        }
      });

      this.customers.push(customer);
    }

    console.log(`生成了 ${this.customers.length} 个客户`);
  }

  private async generateVehicles() {
    console.log('生成车辆数据...');

    const driverNames = [
      '张师傅', '李师傅', '王师傅', '刘师傅', '陈师傅',
      '杨师傅', '赵师傅', '黄师傅', '周师傅', '吴师傅'
    ];

    for (let i = 0; i < 20; i++) {
      const type = faker.helpers.arrayElement(VEHICLE_TYPES);
      const status = faker.helpers.arrayElement(VEHICLE_STATUSES);

      const vehicle = await prisma.vehicle.create({
        data: {
          plateNumber: this.generatePlateNumber(),
          type,
          capacity: faker.number.float({ min: 1, max: 50, precision: 0.1 }),
          driverName: driverNames[i % driverNames.length],
          driverPhone: faker.phone.number('1##########'),
          currentLat: status === 'IN_TRANSIT' ?
            faker.location.latitude({ min: 20, max: 50 }) : null,
          currentLng: status === 'IN_TRANSIT' ?
            faker.location.longitude({ min: 80, max: 130 }) : null,
          status,
          createdAt: faker.date.past({ years: 2 }),
          updatedAt: new Date()
        }
      });

      this.vehicles.push(vehicle);
    }

    console.log(`生成了 ${this.vehicles.length} 辆车辆`);
  }

  private async generateOrders() {
    console.log('生成订单数据...');

    for (let i = 0; i < 200; i++) {
      const customer = faker.helpers.arrayElement(this.customers);
      const originCity = faker.helpers.arrayElement(CITIES);
      const destinationCity = faker.helpers.arrayElement(
        CITIES.filter(city => city.name !== originCity.name)
      );

      const status = this.getRandomStatus();
      const createdAt = faker.date.past({ years: 1 });

      const order = await prisma.order.create({
        data: {
          orderId: this.generateOrderId(),
          customerId: customer.id,
          status,
          origin: {
            address: `${originCity.name}${faker.location.streetAddress()}`,
            contact: faker.person.fullName(),
            phone: faker.phone.number('1##########'),
            lat: originCity.lat + (Math.random() - 0.5) * 0.1,
            lng: originCity.lng + (Math.random() - 0.5) * 0.1
          },
          destination: {
            address: `${destinationCity.name}${faker.location.streetAddress()}`,
            contact: faker.person.fullName(),
            phone: faker.phone.number('1##########'),
            lat: destinationCity.lat + (Math.random() - 0.5) * 0.1,
            lng: destinationCity.lng + (Math.random() - 0.5) * 0.1
          },
          weight: faker.number.float({ min: 0.1, max: 50, precision: 0.1 }),
          volume: faker.number.float({ min: 0.1, max: 100, precision: 0.1 }),
          goodsType: faker.helpers.arrayElement(GOODS_TYPES),
          specialReq: Math.random() > 0.7 ? faker.lorem.sentence() : null,
          scheduledAt: status !== 'PENDING' ?
            faker.date.soon({ days: Math.random() > 0.5 ? 7 : 1 }) : null,
          pickedUpAt: ['PICKED_UP', 'IN_TRANSIT', 'DELIVERED'].includes(status) ?
            faker.date.recent({ days: Math.random() > 0.5 ? 3 : 1 }) : null,
          deliveredAt: status === 'DELIVERED' ?
            faker.date.recent({ days: Math.random() > 0.5 ? 7 : 1 }) : null,
          createdAt,
          updatedAt: new Date()
        }
      });

      this.orders.push(order);
    }

    console.log(`生成了 ${this.orders.length} 个订单`);
  }

  private async generateDispatches() {
    console.log('生成排车数据...');

    const pendingOrders = this.orders.filter(o => o.status === 'PENDING');
    const availableVehicles = this.vehicles.filter(v => v.status === 'AVAILABLE');

    // 生成一些排车记录
    for (let i = 0; i < Math.min(pendingOrders.length / 3, availableVehicles.length); i++) {
      const vehicle = availableVehicles[i];
      const ordersForVehicle = faker.helpers.arrayElements(pendingOrders, {
        min: 1,
        max: 3
      });

      const dispatch = await prisma.dispatch.create({
        data: {
          dispatchNo: this.generateDispatchNo(),
          vehicleId: vehicle.id,
          status: 'SCHEDULED',
          plannedAt: faker.date.soon({ days: 1 }),
          createdAt: new Date(),
          updatedAt: new Date(),
          orders: {
            connect: ordersForVehicle.map(order => ({ id: order.id }))
          }
        }
      });

      // 更新订单状态
      await prisma.order.updateMany({
        where: {
          id: {
            in: ordersForVehicle.map(o => o.id)
          }
        },
        data: {
          status: 'SCHEDULED'
        }
      });
    }
  }

  private async generateTracking() {
    console.log('生成跟踪数据...');

    const inTransitOrders = this.orders.filter(o => o.status === 'IN_TRANSIT');

    for (const order of inTransitOrders) {
      const eventsCount = faker.number.int({ min: 3, max: 8 });

      for (let i = 0; i < eventsCount; i++) {
        const eventTypes = ['已出发', '运输中', '途经点', '预计延误', '正常行驶'];
        const event = faker.helpers.arrayElement(eventTypes);

        await prisma.tracking.create({
          data: {
            orderId: order.id,
            location: {
              lat: faker.location.latitude({ min: 20, max: 50 }),
              lng: faker.location.longitude({ min: 80, max: 130 }),
              address: faker.location.streetAddress()
            },
            event,
            timestamp: faker.date.recent({ days: Math.random() > 0.5 ? 2 : 0.5 })
          }
        });
      }
    }
  }

  private async generatePODs() {
    console.log('生成回单数据...');

    const deliveredOrders = this.orders.filter(o => o.status === 'DELIVERED');

    for (const order of deliveredOrders) {
      if (Math.random() > 0.3) { // 70%的订单有回单
        const podStatuses = ['UPLOADED', 'VERIFIED'] as const;
        const status = faker.helpers.arrayElement(podStatuses);

        await prisma.pOD.create({
          data: {
            orderId: order.id,
            imageUrl: `https://picsum.photos/seed/pod-${order.id}/800/600.jpg`,
            notes: Math.random() > 0.5 ? faker.lorem.sentence() : null,
            status,
            reviewedAt: status === 'VERIFIED' ? faker.date.recent({ days: 1 }) : null,
            createdAt: new Date(),
            updatedAt: new Date()
          }
        });
      }
    }
  }

  private generateOrderId(): string {
    const date = new Date();
    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
    const random = Math.random().toString(36).substr(2, 6).toUpperCase();
    return `ORD${dateStr}${random}`;
  }

  private generateDispatchNo(): string {
    const date = new Date();
    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
    const random = Math.random().toString(36).substr(2, 4).toUpperCase();
    return `DSP${dateStr}${random}`;
  }

  private generatePlateNumber(): string {
    const provinces = ['京', '沪', '粤', '苏', '浙', '鲁', '豫', '川', '湘', '鄂'];
    const province = faker.helpers.arrayElement(provinces);
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const letter = faker.helpers.arrayElement(letters.split(''));
    const numbers = Math.random().toString().slice(2, 6);
    return `${province}${letter}${numbers}`;
  }

  private getRandomStatus() {
    const random = Math.random() * 100;
    let cumulative = 0;

    for (const { status, weight } of ORDER_STATUS_WEIGHTS) {
      cumulative += weight;
      if (random <= cumulative) {
        return status;
      }
    }

    return 'PENDING';
  }
}

// 执行数据生成
async function main() {
  try {
    // 清理现有数据
    console.log('清理现有数据...');
    await prisma.tracking.deleteMany();
    await prisma.pOD.deleteMany();
    await prisma.dispatch.deleteMany();
    await prisma.order.deleteMany();
    await prisma.vehicle.deleteMany();
    await prisma.customer.deleteMany();

    // 生成新数据
    const generator = new DemoDataGenerator();
    await generator.generateAll();

    console.log('演示数据生成完成!');
    process.exit(0);
  } catch (error) {
    console.error('生成演示数据时出错:', error);
    process.exit(1);
  }
}

main();
```

### 演示场景设计
```typescript
// scripts/demo-scenarios.ts
export interface DemoScenario {
  id: string;
  name: string;
  description: string;
  category: 'basic' | 'advanced' | 'comparison' | 'performance';
  difficulty: 'easy' | 'medium' | 'hard';
  estimatedTime: number; // 分钟
  steps: DemoStep[];
  expectedOutcome: string;
  tips: string[];
}

export interface DemoStep {
  id: string;
  name: string;
  description: string;
  action: 'chat' | 'ui' | 'both';
  userInput?: string;
  expectedResponse?: string;
  uiElement?: string;
  waitTime?: number;
  screenshot?: boolean;
}

export const DEMO_SCENARIOS: DemoScenario[] = [
  {
    id: 'basic-order-query',
    name: '基础订单查询',
    description: '演示基本的订单查询功能',
    category: 'basic',
    difficulty: 'easy',
    estimatedTime: 3,
    steps: [
      {
        id: 'step1',
        name: '打开聊天界面',
        description: '进入AI交互模式',
        action: 'ui',
        uiElement: 'chat-interface',
        waitTime: 1
      },
      {
        id: 'step2',
        name: '查询今日订单',
        description: '使用自然语言查询今天的订单',
        action: 'chat',
        userInput: '查询今天所有的订单',
        expectedResponse: '显示今日订单列表',
        waitTime: 3
      },
      {
        id: 'step3',
        name: '筛选特定客户',
        description: '查询特定客户的订单',
        action: 'chat',
        userInput: '查询客户"未来科技"的订单',
        expectedResponse: '显示未来科技的订单',
        waitTime: 2
      }
    ],
    expectedOutcome: '成功展示订单查询功能，用户能够通过自然语言快速查询订单',
    tips: [
      '可以使用多种表达方式查询订单',
      '支持按时间、客户、状态等条件筛选',
      '结果以表格形式清晰展示'
    ]
  },
  {
    id: 'advanced-order-creation',
    name: '高级订单创建',
    description: '演示复杂的订单创建流程',
    category: 'advanced',
    difficulty: 'medium',
    estimatedTime: 5,
    steps: [
      {
        id: 'step1',
        name: '创建新客户订单',
        description: '为现有客户创建新订单',
        action: 'chat',
        userInput: '为"上海科技制造公司"创建一个从浦东新区到北京朝阳区的运输订单，货物为20箱服务器，每箱重25kg',
        expectedResponse: '显示订单创建表单或确认信息',
        waitTime: 3
      },
      {
        id: 'step2',
        name: '指定特殊要求',
        description: '添加运输特殊要求',
        action: 'chat',
        userInput: '添加特殊要求：需要冷藏运输，明天下午3点前送达',
        expectedResponse: '更新订单信息，添加特殊要求',
        waitTime: 2
      },
      {
        id: 'step3',
        name: '确认订单',
        description: '确认订单信息',
        action: 'both',
        userInput: '确认订单信息无误',
        expectedResponse: '订单创建成功，显示订单详情',
        waitTime: 2
      }
    ],
    expectedOutcome: '成功创建包含详细信息的复杂订单，展示AI理解复杂需求的能力',
    tips: [
      'AI能够理解复杂的订单要求',
      '支持多轮对话完善订单信息',
      '自动验证订单信息的完整性'
    ]
  },
  {
    id: 'comparison-traditional-vs-ai',
    name: '传统UI vs AI模式对比',
    description: '对比传统UI操作和AI交互的效率',
    category: 'comparison',
    difficulty: 'medium',
    estimatedTime: 8,
    steps: [
      {
        id: 'step1',
        name: '传统UI模式',
        description: '使用传统UI创建订单',
        action: 'ui',
        uiElement: 'traditional-ui',
        waitTime: 1
      },
      {
        id: 'step2',
        name: '传统UI步骤',
        description: '记录传统UI的操作步骤',
        action: 'ui',
        uiElement: 'order-form',
        waitTime: 10,
        screenshot: true
      },
      {
        id: 'step3',
        name: '切换到AI模式',
        description: '切换到AI交互模式',
        action: 'ui',
        uiElement: 'mode-toggle',
        waitTime: 1
      },
      {
        id: 'step4',
        name: 'AI模式操作',
        description: '使用AI创建相同订单',
        action: 'chat',
        userInput: '创建一个和刚才相同的订单，从上海到北京，20箱服务器',
        expectedResponse: '快速创建订单',
        waitTime: 3
      }
    ],
    expectedOutcome: '展示AI模式相比传统UI的效率优势，减少操作步骤和时间',
    tips: [
      '记录两个模式的操作时间',
      '统计点击次数和填写字段数',
      '展示用户操作的复杂度差异'
    ]
  },
  {
    id: 'dispatch-optimization',
    name: '智能排车优化',
    description: '演示AI智能排车和路线优化',
    category: 'advanced',
    difficulty: 'hard',
    estimatedTime: 6,
    steps: [
      {
        id: 'step1',
        name: '查询待调度订单',
        description: '查看当前待调度的订单',
        action: 'chat',
        userInput: '显示所有待调度的订单',
        expectedResponse: '显示待调度订单列表',
        waitTime: 2
      },
      {
        id: 'step2',
        name: '查询可用车辆',
        description: '查看可用的车辆资源',
        action: 'chat',
        userInput: '查询当前可用的车辆',
        expectedResponse: '显示可用车辆列表',
        waitTime: 2
      },
      {
        id: 'step3',
        name: '智能排车建议',
        description: '让AI提供排车建议',
        action: 'chat',
        userInput: '基于这些订单和车辆，给出最优的排车方案',
        expectedResponse: '显示排车建议和路线优化',
        waitTime: 4
      },
      {
        id: 'step4',
        name: '执行排车',
        description: '确认并执行排车方案',
        action: 'both',
        userInput: '确认执行这个排车方案',
        expectedResponse: '排车成功，更新订单状态',
        waitTime: 2
      }
    ],
    expectedOutcome: '展示AI在复杂排车调度中的智能化能力，包括路线优化和资源分配',
    tips: [
      'AI会考虑多种因素进行优化',
      '包括距离、时间、载重等约束',
      '支持可视化展示排车结果'
    ]
  },
  {
    id: 'real-time-tracking',
    name: '实时车辆跟踪',
    description: '演示实时车辆位置跟踪功能',
    category: 'basic',
    difficulty: 'easy',
    estimatedTime: 4,
    steps: [
      {
        id: 'step1',
        name: '查询在途订单',
        description: '查看正在运输中的订单',
        action: 'chat',
        userInput: '查询正在运输中的订单',
        expectedResponse: '显示在途订单列表',
        waitTime: 2
      },
      {
        id: 'step2',
        name: '跟踪车辆位置',
        description: '查看指定车辆的实时位置',
        action: 'chat',
        userInput: '跟踪订单ORD-001的车辆位置',
        expectedResponse: '显示车辆实时位置和预计到达时间',
        waitTime: 3
      },
      {
        id: 'step3',
        name: '查看运输轨迹',
        description: '查看车辆的历史轨迹',
        action: 'chat',
        userInput: '显示这辆车的运输轨迹',
        expectedResponse: '显示历史轨迹和位置变化',
        waitTime: 2
      }
    ],
    expectedOutcome: '展示实时车辆跟踪功能，包括位置显示、轨迹回放和ETA预测',
    tips: [
      '支持地图可视化展示',
      '实时更新位置信息',
      '提供准确的预计到达时间'
    ]
  },
  {
    id: 'exception-handling',
    name: '异常处理场景',
    description: '演示运输过程中的异常处理',
    category: 'advanced',
    difficulty: 'hard',
    estimatedTime: 7,
    steps: [
      {
        id: 'step1',
        name: '模拟运输延误',
        description: '创建一个运输延误的异常场景',
        action: 'chat',
        userInput: '订单ORD-002出现运输延误，车辆在南京遇到交通堵塞',
        expectedResponse: 'AI识别异常并提供处理建议',
        waitTime: 3
      },
      {
        id: 'step2',
        name: '客户通知',
        description: '通知客户延误情况',
        action: 'chat',
        userInput: '通知客户延误情况并重新预计到达时间',
        expectedResponse: '生成客户通知内容',
        waitTime: 2
      },
      {
        id: 'step3',
        name: '调整计划',
        description: '调整后续运输计划',
        action: 'chat',
        userInput: '根据延误情况调整后续的排车计划',
        expectedResponse: '提供计划调整建议',
        waitTime: 3
      }
    ],
    expectedOutcome: '展示AI在异常处理中的能力，包括问题识别、方案制定和沟通协调',
    tips: [
      'AI能够识别各种异常情况',
      '提供合理的处理建议',
      '协助进行沟通和协调'
    ]
  }
];
```

### 演示脚本管理
```typescript
// scripts/demo-manager.ts
import { DEMO_SCENARIOS, DemoScenario } from './demo-scenarios';

export class DemoManager {
  private currentScenario: DemoScenario | null = null;
  private currentStepIndex = 0;
  private startTime = 0;
  private stepTimes: number[] = [];

  async startScenario(scenarioId: string) {
    const scenario = DEMO_SCENARIOS.find(s => s.id === scenarioId);
    if (!scenario) {
      throw new Error(`Scenario ${scenarioId} not found`);
    }

    this.currentScenario = scenario;
    this.currentStepIndex = 0;
    this.startTime = Date.now();
    this.stepTimes = [];

    console.log(`开始演示场景: ${scenario.name}`);
    console.log(`预计时间: ${scenario.estimatedTime} 分钟`);
    console.log(`难度: ${scenario.difficulty}`);

    await this.executeStep(0);
  }

  private async executeStep(stepIndex: number) {
    if (!this.currentScenario || stepIndex >= this.currentScenario.steps.length) {
      await this.completeScenario();
      return;
    }

    const step = this.currentScenario.steps[stepIndex];
    const stepStartTime = Date.now();

    console.log(`\n步骤 ${stepIndex + 1}: ${step.name}`);
    console.log(`描述: ${step.description}`);
    console.log(`操作类型: ${step.action}`);

    // 执行步骤
    await this.performStep(step);

    // 记录步骤时间
    const stepTime = Date.now() - stepStartTime;
    this.stepTimes.push(stepTime);

    console.log(`步骤完成，耗时: ${stepTime}ms`);

    // 等待指定时间
    if (step.waitTime) {
      console.log(`等待 ${step.waitTime} 秒...`);
      await this.sleep(step.waitTime * 1000);
    }

    // 执行下一步
    this.currentStepIndex = stepIndex + 1;
    await this.executeStep(stepIndex + 1);
  }

  private async performStep(step: any) {
    switch (step.action) {
      case 'chat':
        await this.performChatStep(step);
        break;
      case 'ui':
        await this.performUIStep(step);
        break;
      case 'both':
        await this.performBothStep(step);
        break;
    }
  }

  private async performChatStep(step: any) {
    if (step.userInput) {
      console.log(`用户输入: ${step.userInput}`);

      // 模拟输入到聊天界面
      await this.simulateChatInput(step.userInput);

      // 等待AI响应
      await this.sleep(2000);

      if (step.expectedResponse) {
        console.log(`预期响应: ${step.expectedResponse}`);
      }
    }
  }

  private async performUIStep(step: any) {
    if (step.uiElement) {
      console.log(`操作UI元素: ${step.uiElement}`);

      // 模拟UI操作
      await this.simulateUIOperation(step.uiElement);

      // 等待UI响应
      await this.sleep(1000);
    }
  }

  private async performBothStep(step: any) {
    await this.performUIStep(step);
    await this.performChatStep(step);
  }

  private async completeScenario() {
    if (!this.currentScenario) return;

    const totalTime = Date.now() - this.startTime;
    const averageStepTime = this.stepTimes.reduce((a, b) => a + b, 0) / this.stepTimes.length;

    console.log('\n=== 演示完成 ===');
    console.log(`场景: ${this.currentScenario.name}`);
    console.log(`总耗时: ${totalTime}ms (${(totalTime / 1000 / 60).toFixed(2)} 分钟)`);
    console.log(`预计时间: ${this.currentScenario.estimatedTime} 分钟`);
    console.log(`平均步骤时间: ${averageStepTime}ms`);
    console.log(`步骤数: ${this.currentScenario.steps.length}`);

    if (this.currentScenario.expectedOutcome) {
      console.log(`预期结果: ${this.currentScenario.expectedOutcome}`);
    }

    // 生成演示报告
    await this.generateDemoReport();
  }

  private async generateDemoReport() {
    if (!this.currentScenario) return;

    const report = {
      scenario: {
        id: this.currentScenario.id,
        name: this.currentScenario.name,
        category: this.currentScenario.category,
        difficulty: this.currentScenario.difficulty
      },
      performance: {
        totalTime: Date.now() - this.startTime,
        estimatedTime: this.currentScenario.estimatedTime * 60 * 1000,
        stepTimes: this.stepTimes,
        efficiency: this.stepTimes.length / ((Date.now() - this.startTime) / 1000 / 60)
      },
      steps: this.currentScenario.steps.map((step, index) => ({
        ...step,
        actualTime: this.stepTimes[index] || 0
      }))
    };

    console.log('\n=== 演示报告 ===');
    console.log(JSON.stringify(report, null, 2));

    // 保存报告到文件
    const fs = require('fs');
    const path = require('path');
    const reportPath = path.join(__dirname, `demo-report-${Date.now()}.json`);

    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    console.log(`报告已保存到: ${reportPath}`);
  }

  private async simulateChatInput(input: string) {
    // 这里可以集成到实际的聊天界面
    console.log(`[模拟] 输入到聊天界面: ${input}`);
  }

  private async simulateUIOperation(element: string) {
    // 这里可以集成到实际的UI操作
    console.log(`[模拟] 操作UI元素: ${element}`);
  }

  private async sleep(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // 获取所有场景
  getAllScenarios(): DemoScenario[] {
    return DEMO_SCENARIOS;
  }

  // 按类别获取场景
  getScenariosByCategory(category: string): DemoScenario[] {
    return DEMO_SCENARIOS.filter(s => s.category === category);
  }

  // 按难度获取场景
  getScenariosByDifficulty(difficulty: string): DemoScenario[] {
    return DEMO_SCENARIOS.filter(s => s.difficulty === difficulty);
  }
}

// 使用示例
const demoManager = new DemoManager();

// 命令行接口
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('请指定演示场景ID:');
    console.log(DEMO_SCENARIOS.map(s => `${s.id}: ${s.name}`).join('\n'));
    process.exit(1);
  }

  const scenarioId = args[0];
  demoManager.startScenario(scenarioId).catch(console.error);
}
```

## 交付成果

1. **演示数据生成器**: 自动化生成真实测试数据
2. **演示场景定义**: 详细的演示场景和步骤
3. **演示管理器**: 演示流程控制和报告生成
4. **演示脚本**: 预定义的演示操作步骤
5. **数据验证工具**: 数据质量和一致性检查
6. **演示报告**: 演示效果和性能分析报告
7. **用户指南**: 演示操作说明和最佳实践

## 验收标准

- [ ] 演示数据真实且丰富
- [ ] 覆盖所有核心功能场景
- [ ] 对比演示效果明显
- [ ] 演示流程顺畅
- [ ] 演示时间控制合理
- [ ] 数据生成速度快
- [ ] 场景设计有代表性
- [ ] 用户操作简单
- [ ] 演示报告详细
- [ ] 支持多种演示模式
- [ ] 数据更新维护方便
- [ ] 演示效果可量化

## 相关文件

- `/scripts/generate-demo-data.ts` - 演示数据生成器
- `/scripts/demo-scenarios.ts` - 演示场景定义
- `/scripts/demo-manager.ts` - 演示管理器
- `/scripts/validate-data.ts` - 数据验证工具
- `/data/demo-data.json` - 示例演示数据
- `/docs/demo-guide.md` - 演示操作指南
- `/docs/scenario-catalog.md` - 场景目录说明

## 注意事项

1. 数据真实性：演示数据要尽量真实
2. 场景代表性：场景要覆盖主要使用场景
3. 操作简单性：演示操作要简单易懂
4. 时间控制：严格控制演示时间
5. 效果展示：突出AI优势和价值
6. 应急预案：准备演示异常处理方案
7. 用户反馈：收集用户演示反馈
8. 持续优化：根据反馈优化演示内容