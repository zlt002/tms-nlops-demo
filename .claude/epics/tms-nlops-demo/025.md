---
title: "TMS NL-Ops演示系统任务025: 工具集实现"
epic: "tms-nlops-demo"
task: "025"
phase: "4"
status: "pending"
priority: "high"
estimated_hours: 10
parallel: false
depends_on: ["023", "024"]
tags: ["langgraph", "tools", "api", "business-logic"]
created: "2025-09-20T04:20:45Z"
updated: "2025-09-20T04:20:45Z"
---

## 概述

为TMS NL-Ops演示系统实现完整的工具集，包括订单查询、创建、排车调度、车辆跟踪和回单管理等核心业务功能的工具定义和实现。

## 目标

- 实现订单管理工具集
- 实现排车调度工具集
- 实现车辆跟踪工具集
- 实现回单管理工具集
- 确保工具的安全性和错误处理
- 提供完整的工具文档和示例

## 技术栈

- **工具框架**: LangChain.js Tools
- **数据验证**: Zod schemas
- **HTTP客户端**: fetch API
- **类型系统**: TypeScript 5.5+
- **错误处理**: 自定义错误类型

## 实施步骤

### 1. 创建基础工具类型定义

创建`agent/types/tools.ts`:

```typescript
import { z } from 'zod'

// 工具基础类型
export interface ToolDefinition<TInput = any, TOutput = any> {
  name: string
  description: string
  schema: z.ZodType<TInput>
  handler: (input: TInput, context: ToolContext) => Promise<TOutput>
  requiresAuth?: boolean
  rateLimit?: {
    max: number
    window: number // 毫秒
  }
}

// 工具上下文
export interface ToolContext {
  sessionId: string
  userId?: string
  userRole: string
  metadata: Record<string, any>
  startTime: number
}

// 工具执行结果
export interface ToolResult<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: any
  }
  metadata?: {
    executionTime: number
    tokensUsed?: number
    cacheHit?: boolean
  }
}

// 分页参数
export const PaginationSchema = z.object({
  page: z.number().int().min(1).default(1),
  pageSize: z.number().int().min(1).max(100).default(20),
})

export type PaginationParams = z.infer<typeof PaginationSchema>

// 排序参数
export const SortSchema = z.object({
  field: z.string(),
  order: z.enum(['asc', 'desc']).default('asc'),
})

export type SortParams = z.infer<typeof SortSchema>

// 搜索参数
export const SearchSchema = z.object({
  query: z.string().optional(),
  filters: z.record(z.any()).optional(),
})

export type SearchParams = z.infer<typeof SearchSchema>

// 地理位置类型
export const LocationSchema = z.object({
  address: z.string(),
  latitude: z.number().optional(),
  longitude: z.number().optional(),
  contact: z.string().optional(),
  phone: z.string().optional(),
})

export type Location = z.infer<typeof LocationSchema>

// 货物信息类型
export const GoodsSchema = z.object({
  name: z.string(),
  quantity: z.number().positive(),
  weight: z.number().positive().optional(),
  volume: z.number().positive().optional(),
  special: z.string().optional(),
  value: z.number().optional(),
})

export type Goods = z.infer<typeof GoodsSchema>
```

### 2. 实现订单管理工具

创建`agent/tools/order-tools.ts`:

```typescript
import { tool } from '@langchain/core/tools'
import { z } from 'zod'
import { ToolDefinition, ToolResult, PaginationParams, SearchParams, SortParams, Location, Goods } from '../types/tools'

// 订单查询工具
export const queryOrdersTool = tool(
  async (
    { customerName, status, dateRange, pagination, search }: {
      customerName?: string
      status?: string
      dateRange?: { start: string; end: string }
      pagination?: PaginationParams
      search?: SearchParams
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      // 构建查询参数
      const params = new URLSearchParams()
      if (customerName) params.append('customerName', customerName)
      if (status) params.append('status', status)
      if (dateRange) {
        params.append('startDate', dateRange.start)
        params.append('endDate', dateRange.end)
      }
      if (pagination) {
        params.append('page', pagination.page.toString())
        params.append('pageSize', pagination.pageSize.toString())
      }
      if (search?.query) params.append('search', search.query)
      if (search?.filters) params.append('filters', JSON.stringify(search.filters))

      // 调用后端API
      const response = await fetch(`/api/tms/orders?${params}`, {
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status} ${response.statusText}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.orders || [],
        metadata: {
          executionTime,
          total: data.total,
          pagination: data.pagination,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'QUERY_ORDERS_ERROR',
          message: error instanceof Error ? error.message : 'Failed to query orders',
        },
      }
    }
  },
  {
    name: 'queryOrders',
    description: '查询订单列表，支持客户名称、状态、日期范围等筛选条件，以及分页和搜索功能',
    schema: z.object({
      customerName: z.string().optional().describe('客户名称，支持模糊查询'),
      status: z.enum(['PENDING', 'SCHEDULED', 'PICKED_UP', 'IN_TRANSIT', 'DELIVERED', 'CANCELLED']).optional()
        .describe('订单状态：待处理、已排班、已取货、在途、已送达、已取消'),
      dateRange: z.object({
        start: z.string().describe('开始日期，格式：YYYY-MM-DD'),
        end: z.string().describe('结束日期，格式：YYYY-MM-DD'),
      }).optional().describe('日期范围筛选'),
      pagination: z.object({
        page: z.number().int().min(1).default(1).describe('页码'),
        pageSize: z.number().int().min(1).max(100).default(20).describe('每页数量'),
      }).optional().describe('分页参数'),
      search: z.object({
        query: z.string().optional().describe('搜索关键词'),
        filters: z.record(z.any()).optional().describe('高级筛选条件'),
      }).optional().describe('搜索参数'),
    }),
  }
)

// 创建订单工具
export const createOrderTool = tool(
  async (
    { customerName, origin, destination, goods, scheduledAt, specialReq }: {
      customerName: string
      origin: Location
      destination: Location
      goods: Goods[]
      scheduledAt?: string
      specialReq?: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      // 验证输入
      if (!customerName || !origin || !destination || !goods || goods.length === 0) {
        throw new Error('Missing required fields: customerName, origin, destination, goods')
      }

      // 构建订单数据
      const orderData = {
        customerName,
        origin,
        destination,
        goods,
        scheduledAt: scheduledAt ? new Date(scheduledAt).toISOString() : undefined,
        specialReq,
      }

      // 调用后端API
      const response = await fetch('/api/tms/orders', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(orderData),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || 'Failed to create order')
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.order,
        metadata: {
          executionTime,
          orderId: data.order.id,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'CREATE_ORDER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to create order',
        },
      }
    }
  },
  {
    name: 'createOrder',
    description: '创建新的运输订单，需要提供客户信息、起终点地址、货物信息和期望发货时间',
    schema: z.object({
      customerName: z.string().describe('客户名称'),
      origin: z.object({
        address: z.string().describe('起始地址'),
        latitude: z.number().optional().describe('纬度'),
        longitude: z.number().optional().describe('经度'),
        contact: z.string().optional().describe('联系人'),
        phone: z.string().optional().describe('联系电话'),
      }).describe('起始地点信息'),
      destination: z.object({
        address: z.string().describe('目的地地址'),
        latitude: z.number().optional().describe('纬度'),
        longitude: z.number().optional().describe('经度'),
        contact: z.string().optional().describe('联系人'),
        phone: z.string().optional().describe('联系电话'),
      }).describe('目的地信息'),
      goods: z.array(z.object({
        name: z.string().describe('货物名称'),
        quantity: z.number().positive().describe('数量'),
        weight: z.number().positive().optional().describe('重量(kg)'),
        volume: z.number().positive().optional().describe('体积(m³)'),
        special: z.string().optional().describe('特殊要求'),
        value: z.number().optional().describe('货物价值'),
      })).describe('货物信息列表'),
      scheduledAt: z.string().optional().describe('期望发货时间，格式：YYYY-MM-DD HH:mm'),
      specialReq: z.string().optional().describe('特殊要求说明'),
    }),
  }
)

// 更新订单状态工具
export const updateOrderStatusTool = tool(
  async (
    { orderId, status, notes }: {
      orderId: string
      status: string
      notes?: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const response = await fetch(`/api/tms/orders/${orderId}/status`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify({ status, notes }),
      })

      if (!response.ok) {
        throw new Error(`Failed to update order status: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.order,
        metadata: {
          executionTime,
          status: data.order.status,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'UPDATE_ORDER_STATUS_ERROR',
          message: error instanceof Error ? error.message : 'Failed to update order status',
        },
      }
    }
  },
  {
    name: 'updateOrderStatus',
    description: '更新订单状态，可以添加状态变更说明',
    schema: z.object({
      orderId: z.string().describe('订单ID'),
      status: z.enum(['PENDING', 'SCHEDULED', 'PICKED_UP', 'IN_TRANSIT', 'DELIVERED', 'CANCELLED'])
        .describe('订单状态'),
      notes: z.string().optional().describe('状态变更说明'),
    }),
  }
)

// 获取订单详情工具
export const getOrderDetailTool = tool(
  async (
    { orderId }: { orderId: string },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const response = await fetch(`/api/tms/orders/${orderId}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to get order details: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.order,
        metadata: {
          executionTime,
          orderId,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'GET_ORDER_DETAIL_ERROR',
          message: error instanceof Error ? error.message : 'Failed to get order details',
        },
      }
    }
  },
  {
    name: 'getOrderDetail',
    description: '获取订单详细信息，包括订单状态、货物信息、调度信息等',
    schema: z.object({
      orderId: z.string().describe('订单ID'),
    }),
  }
)

// 取消订单工具
export const cancelOrderTool = tool(
  async (
    { orderId, reason }: {
      orderId: string
      reason: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const response = await fetch(`/api/tms/orders/${orderId}/cancel`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify({ reason }),
      })

      if (!response.ok) {
        throw new Error(`Failed to cancel order: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.order,
        metadata: {
          executionTime,
          orderId,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'CANCEL_ORDER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to cancel order',
        },
      }
    }
  },
  {
    name: 'cancelOrder',
    description: '取消订单，需要提供取消原因',
    schema: z.object({
      orderId: z.string().describe('订单ID'),
      reason: z.string().describe('取消原因'),
    }),
  }
)
```

### 3. 实现排车调度工具

创建`agent/tools/dispatch-tools.ts`:

```typescript
import { tool } from '@langchain/core/tools'
import { z } from 'zod'

// 获取待调度订单工具
export const getPendingOrdersTool = tool(
  async (
    { vehicleType, area, maxWeight }: {
      vehicleType?: string
      area?: string
      maxWeight?: number
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const params = new URLSearchParams()
      if (vehicleType) params.append('vehicleType', vehicleType)
      if (area) params.append('area', area)
      if (maxWeight) params.append('maxWeight', maxWeight.toString())

      const response = await fetch(`/api/tms/dispatch/pending?${params}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to get pending orders: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.orders,
        metadata: {
          executionTime,
          total: data.total,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'GET_PENDING_ORDERS_ERROR',
          message: error instanceof Error ? error.message : 'Failed to get pending orders',
        },
      }
    }
  },
  {
    name: 'getPendingOrders',
    description: '获取待调度订单列表，支持按车辆类型、区域、最大重量等条件筛选',
    schema: z.object({
      vehicleType: z.enum(['TRUCK', 'VAN', 'REFRIGERATED', 'FLATBED']).optional()
        .describe('车辆类型：卡车、面包车、冷藏车、平板车'),
      area: z.string().optional().describe('区域筛选'),
      maxWeight: z.number().positive().optional().describe('最大载重(kg)'),
    }),
  }
)

// 获取可用车辆工具
export const getAvailableVehiclesTool = tool(
  async (
    { vehicleType, capacity, location }: {
      vehicleType?: string
      capacity?: number
      location?: { latitude: number; longitude: number; radius: number }
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const params = new URLSearchParams()
      if (vehicleType) params.append('vehicleType', vehicleType)
      if (capacity) params.append('capacity', capacity.toString())
      if (location) {
        params.append('lat', location.latitude.toString())
        params.append('lng', location.longitude.toString())
        params.append('radius', location.radius.toString())
      }

      const response = await fetch(`/api/tms/vehicles/available?${params}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to get available vehicles: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.vehicles,
        metadata: {
          executionTime,
          total: data.total,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'GET_AVAILABLE_VEHICLES_ERROR',
          message: error instanceof Error ? error.message : 'Failed to get available vehicles',
        },
      }
    }
  },
  {
    name: 'getAvailableVehicles',
    description: '获取可用车辆列表，支持按车辆类型、载重能力、位置等条件筛选',
    schema: z.object({
      vehicleType: z.enum(['TRUCK', 'VAN', 'REFRIGERATED', 'FLATBED']).optional()
        .describe('车辆类型'),
      capacity: z.number().positive().optional().describe('最小载重能力(kg)'),
      location: z.object({
        latitude: z.number().describe('中心点纬度'),
        longitude: z.number().describe('中心点经度'),
        radius: z.number().positive().describe('搜索半径(km)'),
      }).optional().describe('位置筛选'),
    }),
  }
)

// 创建排车计划工具
export const createDispatchTool = tool(
  async (
    { orderIds, vehicleId, route, estimatedDuration }: {
      orderIds: string[]
      vehicleId: string
      route: {
        waypoints: Array<{
          address: string
          latitude: number
          longitude: number
          type: 'pickup' | 'delivery'
          orderId: string
        }>
        totalDistance: number
      }
      estimatedDuration: number
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const dispatchData = {
        orderIds,
        vehicleId,
        route,
        estimatedDuration,
      }

      const response = await fetch('/api/tms/dispatch', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(dispatchData),
      })

      if (!response.ok) {
        throw new Error(`Failed to create dispatch: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.dispatch,
        metadata: {
          executionTime,
          dispatchId: data.dispatch.id,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'CREATE_DISPATCH_ERROR',
          message: error instanceof Error ? error.message : 'Failed to create dispatch',
        },
      }
    }
  },
  {
    name: 'createDispatch',
    description: '创建排车计划，将多个订单分配给指定车辆并规划路线',
    schema: z.object({
      orderIds: z.array(z.string()).describe('订单ID列表'),
      vehicleId: z.string().describe('车辆ID'),
      route: z.object({
        waypoints: z.array(z.object({
          address: z.string().describe('地址'),
          latitude: z.number().describe('纬度'),
          longitude: z.number().describe('经度'),
          type: z.enum(['pickup', 'delivery']).describe('类型：取货或送货'),
          orderId: z.string().describe('对应的订单ID'),
        })).describe('路线途经点'),
        totalDistance: z.number().positive().describe('总距离(km)'),
      }).describe('路线规划'),
      estimatedDuration: z.number().positive().describe('预计用时(分钟)'),
    }),
  }
)

// 更新排车状态工具
export const updateDispatchStatusTool = tool(
  async (
    { dispatchId, status, actualStartTime, actualEndTime }: {
      dispatchId: string
      status: string
      actualStartTime?: string
      actualEndTime?: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const updateData = {
        status,
        actualStartTime: actualStartTime ? new Date(actualStartTime).toISOString() : undefined,
        actualEndTime: actualEndTime ? new Date(actualEndTime).toISOString() : undefined,
      }

      const response = await fetch(`/api/tms/dispatch/${dispatchId}/status`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(updateData),
      })

      if (!response.ok) {
        throw new Error(`Failed to update dispatch status: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.dispatch,
        metadata: {
          executionTime,
          dispatchId,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'UPDATE_DISPATCH_STATUS_ERROR',
          message: error instanceof Error ? error.message : 'Failed to update dispatch status',
        },
      }
    }
  },
  {
    name: 'updateDispatchStatus',
    description: '更新排车状态，记录实际开始和结束时间',
    schema: z.object({
      dispatchId: z.string().describe('排车ID'),
      status: z.enum(['PLANNING', 'SCHEDULED', 'IN_TRANSIT', 'COMPLETED', 'CANCELLED'])
        .describe('排车状态'),
      actualStartTime: z.string().optional().describe('实际开始时间，格式：YYYY-MM-DD HH:mm'),
      actualEndTime: z.string().optional().describe('实际结束时间，格式：YYYY-MM-DD HH:mm'),
    }),
  }
)
```

### 4. 实现车辆跟踪工具

创建`agent/tools/tracking-tools.ts`:

```typescript
import { tool } from '@langchain/core/tools'
import { z } from 'zod'

// 查询车辆位置工具
export const trackVehicleTool = tool(
  async (
    { vehicleId, includeRoute }: {
      vehicleId: string
      includeRoute?: boolean
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const params = new URLSearchParams()
      if (includeRoute) params.append('includeRoute', 'true')

      const response = await fetch(`/api/tms/tracking/vehicles/${vehicleId}?${params}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to track vehicle: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: {
          vehicle: data.vehicle,
          route: includeRoute ? data.route : undefined,
        },
        metadata: {
          executionTime,
          vehicleId,
          lastUpdate: data.vehicle.lastUpdate,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'TRACK_VEHICLE_ERROR',
          message: error instanceof Error ? error.message : 'Failed to track vehicle',
        },
      }
    }
  },
  {
    name: 'trackVehicle',
    description: '查询车辆的实时位置和运行状态，可选择是否包含路线信息',
    schema: z.object({
      vehicleId: z.string().describe('车辆ID'),
      includeRoute: z.boolean().optional().describe('是否包含路线信息'),
    }),
  }
)

// 查询订单跟踪信息工具
export const trackOrderTool = tool(
  async (
    { orderId, includeHistory }: {
      orderId: string
      includeHistory?: boolean
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const params = new URLSearchParams()
      if (includeHistory) params.append('includeHistory', 'true')

      const response = await fetch(`/api/tms/tracking/orders/${orderId}?${params}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to track order: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: {
          order: data.order,
          currentLocation: data.currentLocation,
          estimatedArrival: data.estimatedArrival,
          history: includeHistory ? data.history : undefined,
        },
        metadata: {
          executionTime,
          orderId,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'TRACK_ORDER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to track order',
        },
      }
    }
  },
  {
    name: 'trackOrder',
    description: '查询订单的跟踪信息，包括当前位置、预计到达时间等',
    schema: z.object({
      orderId: z.string().describe('订单ID'),
      includeHistory: z.boolean().optional().describe('是否包含历史轨迹'),
    }),
  }
)

// 上报位置事件工具
export const reportLocationEventTool = tool(
  async (
    { vehicleId, location, eventType, orderId, speed }: {
      vehicleId: string
      location: {
        latitude: number
        longitude: number
        address?: string
      }
      eventType: string
      orderId?: string
      speed?: number
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const eventData = {
        vehicleId,
        location,
        eventType,
        orderId,
        speed,
        timestamp: new Date().toISOString(),
      }

      const response = await fetch('/api/tms/tracking/events', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(eventData),
      })

      if (!response.ok) {
        throw new Error(`Failed to report location event: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.event,
        metadata: {
          executionTime,
          eventId: data.event.id,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'REPORT_LOCATION_EVENT_ERROR',
          message: error instanceof Error ? error.message : 'Failed to report location event',
        },
      }
    }
  },
  {
    name: 'reportLocationEvent',
    description: '上报车辆位置事件，如到达、出发、异常等',
    schema: z.object({
      vehicleId: z.string().describe('车辆ID'),
      location: z.object({
        latitude: z.number().describe('纬度'),
        longitude: z.number().describe('经度'),
        address: z.string().optional().describe('地址描述'),
      }).describe('位置信息'),
      eventType: z.enum(['ARRIVAL', 'DEPARTURE', 'DELAY', 'ACCIDENT', 'FUEL_STOP', 'REST_STOP'])
        .describe('事件类型'),
      orderId: z.string().optional().describe('关联的订单ID'),
      speed: z.number().min(0).optional().describe('当前速度(km/h)'),
    }),
  }
)

// 获取车辆历史轨迹工具
export const getVehicleHistoryTool = tool(
  async (
    { vehicleId, startDate, endDate }: {
      vehicleId: string
      startDate: string
      endDate: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const params = new URLSearchParams()
      params.append('startDate', startDate)
      params.append('endDate', endDate)

      const response = await fetch(`/api/tms/tracking/vehicles/${vehicleId}/history?${params}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to get vehicle history: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.history,
        metadata: {
          executionTime,
          vehicleId,
          points: data.history.length,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'GET_VEHICLE_HISTORY_ERROR',
          message: error instanceof Error ? error.message : 'Failed to get vehicle history',
        },
      }
    }
  },
  {
    name: 'getVehicleHistory',
    description: '获取指定时间范围内车辆的历史轨迹',
    schema: z.object({
      vehicleId: z.string().describe('车辆ID'),
      startDate: z.string().describe('开始时间，格式：YYYY-MM-DD HH:mm'),
      endDate: z.string().describe('结束时间，格式：YYYY-MM-DD HH:mm'),
    }),
  }
)
```

### 5. 实现回单管理工具

创建`agent/tools/pod-tools.ts`:

```typescript
import { tool } from '@langchain/core/tools'
import { z } from 'zod'

// 上传回单工具
export const uploadPODTool = tool(
  async (
    { orderId, imageData, notes, verificationMethod }: {
      orderId: string
      imageData: string
      notes?: string
      verificationMethod?: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      // 验证图片数据
      if (!imageData.startsWith('data:image/')) {
        throw new Error('Invalid image data format')
      }

      const podData = {
        orderId,
        imageData,
        notes,
        verificationMethod,
        uploadTime: new Date().toISOString(),
      }

      const response = await fetch(`/api/tms/pod/${orderId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(podData),
      })

      if (!response.ok) {
        throw new Error(`Failed to upload POD: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.pod,
        metadata: {
          executionTime,
          podId: data.pod.id,
          orderId,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'UPLOAD_POD_ERROR',
          message: error instanceof Error ? error.message : 'Failed to upload POD',
        },
      }
    }
  },
  {
    name: 'uploadPOD',
    description: '上传订单回单图片，支持添加备注和验证方式',
    schema: z.object({
      orderId: z.string().describe('订单ID'),
      imageData: z.string().describe('图片数据，base64编码'),
      notes: z.string().optional().describe('备注信息'),
      verificationMethod: z.enum(['PHOTO', 'SIGNATURE', 'QRCODE', 'MANUAL']).optional()
        .describe('验证方式：拍照、签名、二维码、手动'),
    }),
  }
)

// 验证回单工具
export const verifyPODTool = tool(
  async (
    { podId, verificationResult, notes }: {
      podId: string
      verificationResult: 'APPROVED' | 'REJECTED' | 'NEEDS_REVIEW'
      notes?: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const verificationData = {
        result: verificationResult,
        notes,
        verifiedBy: context.userId,
        verifiedAt: new Date().toISOString(),
      }

      const response = await fetch(`/api/tms/pod/${podId}/verify`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(verificationData),
      })

      if (!response.ok) {
        throw new Error(`Failed to verify POD: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.pod,
        metadata: {
          executionTime,
          podId,
          status: data.pod.status,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'VERIFY_POD_ERROR',
          message: error instanceof Error ? error.message : 'Failed to verify POD',
        },
      }
    }
  },
  {
    name: 'verifyPOD',
    description: '验证回单图片，标记为通过、拒绝或需要重新审核',
    schema: z.object({
      podId: z.string().describe('回单ID'),
      verificationResult: z.enum(['APPROVED', 'REJECTED', 'NEEDS_REVIEW'])
        .describe('验证结果'),
      notes: z.string().optional().describe('验证说明'),
    }),
  }
)

// 查询回单工具
export const queryPODTool = tool(
  async (
    { orderId, podId }: {
      orderId?: string
      podId?: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      let url = '/api/tms/pod'
      if (orderId) {
        url += `/order/${orderId}`
      } else if (podId) {
        url += `/${podId}`
      }

      const response = await fetch(url, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to query POD: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.pod || data.pods,
        metadata: {
          executionTime,
          orderId: orderId || data.pod?.orderId,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'QUERY_POD_ERROR',
          message: error instanceof Error ? error.message : 'Failed to query POD',
        },
      }
    }
  },
  {
    name: 'queryPOD',
    description: '查询回单信息，支持按订单ID或回单ID查询',
    schema: z.object({
      orderId: z.string().optional().describe('订单ID'),
      podId: z.string().optional().describe('回单ID'),
    }),
  }
)

// 获取待审核回单列表工具
export const getPendingPODsTool = tool(
  async (
    { dateRange, verifier }: {
      dateRange?: { start: string; end: string }
      verifier?: string
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const params = new URLSearchParams()
      if (dateRange) {
        params.append('startDate', dateRange.start)
        params.append('endDate', dateRange.end)
      }
      if (verifier) params.append('verifier', verifier)

      const response = await fetch(`/api/tms/pod/pending?${params}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to get pending PODs: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.pods,
        metadata: {
          executionTime,
          total: data.total,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'GET_PENDING_PODS_ERROR',
          message: error instanceof Error ? error.message : 'Failed to get pending PODs',
        },
      }
    }
  },
  {
    name: 'getPendingPODs',
    description: '获取待审核的回单列表',
    schema: z.object({
      dateRange: z.object({
        start: z.string().describe('开始日期，格式：YYYY-MM-DD'),
        end: z.string().describe('结束日期，格式：YYYY-MM-DD'),
      }).optional().describe('日期范围'),
      verifier: z.string().optional().describe('审核人'),
    }),
  }
)
```

### 6. 实现通用工具

创建`agent/tools/common-tools.ts`:

```typescript
import { tool } from '@langchain/core/tools'
import { z } from 'zod'

// 获取当前时间工具
export const getCurrentTimeTool = tool(
  async (
    { timezone }: { timezone?: string },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const now = new Date()
      const options: Intl.DateTimeFormatOptions = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZone: timezone || 'Asia/Shanghai',
      }

      const formattedTime = now.toLocaleString('zh-CN', options)
      const timestamp = now.getTime()

      return {
        success: true,
        data: {
          currentTime: formattedTime,
          timestamp,
          timezone: timezone || 'Asia/Shanghai',
          isoString: now.toISOString(),
        },
        metadata: {
          executionTime: Date.now() - startTime,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'GET_CURRENT_TIME_ERROR',
          message: error instanceof Error ? error.message : 'Failed to get current time',
        },
      }
    }
  },
  {
    name: 'getCurrentTime',
    description: '获取当前时间，支持指定时区',
    schema: z.object({
      timezone: z.string().optional().describe('时区，默认为Asia/Shanghai'),
    }),
  }
)

// 搜索客户工具
export const searchCustomersTool = tool(
  async (
    { query, type, limit }: {
      query: string
      type?: 'name' | 'phone' | 'email'
      limit?: number
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const params = new URLSearchParams()
      params.append('query', query)
      if (type) params.append('type', type)
      if (limit) params.append('limit', limit.toString())

      const response = await fetch(`/api/tms/customers/search?${params}`, {
        headers: {
          'X-Session-ID': context.sessionId,
        },
      })

      if (!response.ok) {
        throw new Error(`Failed to search customers: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: data.customers,
        metadata: {
          executionTime,
          total: data.total,
          query,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'SEARCH_CUSTOMERS_ERROR',
          message: error instanceof Error ? error.message : 'Failed to search customers',
        },
      }
    }
  },
  {
    name: 'searchCustomers',
    description: '搜索客户信息，支持按姓名、电话、邮箱等条件搜索',
    schema: z.object({
      query: z.string().describe('搜索关键词'),
      type: z.enum(['name', 'phone', 'email']).optional().describe('搜索类型'),
      limit: z.number().int().min(1).max(50).optional().describe('返回结果数量限制'),
    }),
  }
)

// 计算路线距离工具
export const calculateRouteTool = tool(
  async (
    { origin, destination, waypoints }: {
      origin: { latitude: number; longitude: number; address?: string }
      destination: { latitude: number; longitude: number; address?: string }
      waypoints?: Array<{ latitude: number; longitude: number; address?: string }>
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const routeData = {
        origin,
        destination,
        waypoints,
      }

      const response = await fetch('/api/tms/route/calculate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(routeData),
      })

      if (!response.ok) {
        throw new Error(`Failed to calculate route: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: {
          distance: data.distance,
          duration: data.duration,
          route: data.route,
          waypoints: data.waypoints,
        },
        metadata: {
          executionTime,
          distance: data.distance,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'CALCULATE_ROUTE_ERROR',
          message: error instanceof Error ? error.message : 'Failed to calculate route',
        },
      }
    }
  },
  {
    name: 'calculateRoute',
    description: '计算路线距离和预计时间，支持途经点',
    schema: z.object({
      origin: z.object({
        latitude: z.number().describe('起点纬度'),
        longitude: z.number().describe('起点经度'),
        address: z.string().optional().describe('起点地址'),
      }).describe('起点信息'),
      destination: z.object({
        latitude: z.number().describe('终点纬度'),
        longitude: z.number().describe('终点经度'),
        address: z.string().optional().describe('终点地址'),
      }).describe('终点信息'),
      waypoints: z.array(z.object({
        latitude: z.number().describe('途经点纬度'),
        longitude: z.number().describe('途经点经度'),
        address: z.string().optional().describe('途经点地址'),
      })).optional().describe('途经点列表'),
    }),
  }
)

// 生成报告工具
export const generateReportTool = tool(
  async (
    { reportType, dateRange, filters, format }: {
      reportType: string
      dateRange: { start: string; end: string }
      filters?: Record<string, any>
      format?: 'json' | 'csv' | 'pdf'
    },
    context: ToolContext
  ) => {
    try {
      const startTime = Date.now()

      const reportData = {
        reportType,
        dateRange,
        filters,
        format: format || 'json',
      }

      const response = await fetch('/api/tms/reports/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': context.sessionId,
        },
        body: JSON.stringify(reportData),
      })

      if (!response.ok) {
        throw new Error(`Failed to generate report: ${response.status}`)
      }

      const data = await response.json()
      const executionTime = Date.now() - startTime

      return {
        success: true,
        data: {
          reportId: data.reportId,
          downloadUrl: data.downloadUrl,
          reportType,
          generatedAt: data.generatedAt,
        },
        metadata: {
          executionTime,
          reportId: data.reportId,
        },
      }
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'GENERATE_REPORT_ERROR',
          message: error instanceof Error ? error.message : 'Failed to generate report',
        },
      }
    }
  },
  {
    name: 'generateReport',
    description: '生成各类业务报告，支持订单、车辆、客户等维度的统计分析',
    schema: z.object({
      reportType: z.enum(['orders', 'vehicles', 'customers', 'dispatch', 'financial'])
        .describe('报告类型'),
      dateRange: z.object({
        start: z.string().describe('开始日期，格式：YYYY-MM-DD'),
        end: z.string().describe('结束日期，格式：YYYY-MM-DD'),
      }).describe('日期范围'),
      filters: z.record(z.any()).optional().describe('筛选条件'),
      format: z.enum(['json', 'csv', 'pdf']).optional().describe('输出格式'),
    }),
  }
)
```

### 7. 创建工具集导出文件

创建`agent/tools/index.ts`:

```typescript
// 订单管理工具
export {
  queryOrdersTool,
  createOrderTool,
  updateOrderStatusTool,
  getOrderDetailTool,
  cancelOrderTool,
} from './order-tools'

// 排车调度工具
export {
  getPendingOrdersTool,
  getAvailableVehiclesTool,
  createDispatchTool,
  updateDispatchStatusTool,
} from './dispatch-tools'

// 车辆跟踪工具
export {
  trackVehicleTool,
  trackOrderTool,
  reportLocationEventTool,
  getVehicleHistoryTool,
} from './tracking-tools'

// 回单管理工具
export {
  uploadPODTool,
  verifyPODTool,
  queryPODTool,
  getPendingPODsTool,
} from './pod-tools'

// 通用工具
export {
  getCurrentTimeTool,
  searchCustomersTool,
  calculateRouteTool,
  generateReportTool,
} from './common-tools'

// 所有工具列表
export const allTools = [
  // 订单管理工具
  queryOrdersTool,
  createOrderTool,
  updateOrderStatusTool,
  getOrderDetailTool,
  cancelOrderTool,

  // 排车调度工具
  getPendingOrdersTool,
  getAvailableVehiclesTool,
  createDispatchTool,
  updateDispatchStatusTool,

  // 车辆跟踪工具
  trackVehicleTool,
  trackOrderTool,
  reportLocationEventTool,
  getVehicleHistoryTool,

  // 回单管理工具
  uploadPODTool,
  verifyPODTool,
  queryPODTool,
  getPendingPODsTool,

  // 通用工具
  getCurrentTimeTool,
  searchCustomersTool,
  calculateRouteTool,
  generateReportTool,
]

// 按类别分组的工具
export const toolCategories = {
  orders: [
    queryOrdersTool,
    createOrderTool,
    updateOrderStatusTool,
    getOrderDetailTool,
    cancelOrderTool,
  ],
  dispatch: [
    getPendingOrdersTool,
    getAvailableVehiclesTool,
    createDispatchTool,
    updateDispatchStatusTool,
  ],
  tracking: [
    trackVehicleTool,
    trackOrderTool,
    reportLocationEventTool,
    getVehicleHistoryTool,
  ],
  pod: [
    uploadPODTool,
    verifyPODTool,
    queryPODTool,
    getPendingPODsTool,
  ],
  common: [
    getCurrentTimeTool,
    searchCustomersTool,
    calculateRouteTool,
    generateReportTool,
  ],
}
```

## 验证清单

- [ ] 订单管理工具集实现完整
- [ ] 排车调度工具集实现完整
- [ ] 车辆跟踪工具集实现完整
- [ ] 回单管理工具集实现完整
- [ ] 通用工具实现完整
- [ ] 所有工具schema定义正确
- [ ] 错误处理机制完善
- [ ] 工具导出文件结构正确
- [ ] 工具分类和组织合理
- [ ] 工具文档和描述完整

## 测试命令

```bash
# 类型检查
npm run type-check

# 运行工具测试
npm test -- agent/tools

# 集成测试
npm run test:integration

# 工具性能测试
npm run test:performance
```

## 注意事项

- 所有工具都需要正确处理错误情况
- 工具的schema定义需要准确反映参数要求
- 需要考虑API调用超时和重试机制
- 工具的描述需要详细且易于理解
- 需要实现工具的访问权限控制

## 下一步

完成本任务后，将进行任务026: Supervisor节点实现，将所有工具集成到智能决策系统中。完整的工具集将为Agent提供强大的业务功能支持。