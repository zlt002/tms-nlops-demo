---
title: 部署配置和CI/CD流水线
epic: tms-nlops-demo
task_id: 040
type: task
status: todo
priority: high
tags: ["deployment", "cicd", "devops", "infrastructure", "automation"]
assignee: ""
created: 2025-09-20T04:20:45Z
updated: 2025-09-20T04:20:45Z
parallel: false
depends_on: ["016", "017", "018", "019", "020", "021", "022", "023", "024", "025", "030", "031", "032", "033", "034", "035", "036", "037", "038", "039"]
effort: 5
description: 配置生产部署环境和建立CI/CD自动化流水线
---

## 任务描述

配置TMS NL-Ops演示系统的生产部署环境，建立完整的CI/CD自动化流水线，包括代码检查、自动测试、构建部署、环境管理和监控告警等功能。

## 详细需求

### 1. 部署环境配置
- **云平台选择**: 选择合适的云服务平台
- **基础设施**: 服务器、数据库、缓存等资源配置
- **域名配置**: 域名解析和SSL证书
- **网络配置**: 负载均衡、CDN、防火墙等
- **环境隔离**: 开发、测试、生产环境隔离

### 2. CI/CD流水线
- **代码检查**: 代码质量检查和格式化
- **自动化测试**: 单元测试、集成测试、端到端测试
- **构建优化**: 代码打包和优化
- **自动部署**: 自动化部署到各环境
- **回滚机制**: 快速回滚和故障恢复

### 3. 容器化部署
- **Docker配置**: 应用容器化配置
- **容器编排**: Kubernetes或类似平台配置
- **镜像管理**: 镜像构建和版本管理
- **服务发现**: 服务注册和发现机制
- **配置管理**: 环境配置和密钥管理

### 4. 监控和日志
- **应用监控**: 应用性能和错误监控
- **基础设施监控**: 服务器和资源监控
- **日志管理**: 日志收集和分析
- **告警配置**: 自动告警和通知
- **性能分析**: 性能指标和分析报告

## 技术实现

### Vercel部署配置
```yaml
# vercel.json
{
  "version": 2,
  "public": true,
  "github": {
    "silent": true
  },
  "functions": {
    "app/api/**/*.{js,ts}": {
      "maxDuration": 30,
      "memory": 1024
    },
    "app/api/chat/route.{js,ts}": {
      "maxDuration": 60,
      "memory": 2048
    }
  },
  "env": {
    "NODE_ENV": "production",
    "NEXT_PUBLIC_APP_URL": "https://tms-demo.vercel.app",
    "DATABASE_URL": "@database_url",
    "REDIS_URL": "@redis_url",
    "OPENAI_API_KEY": "@openai_api_key",
    "NEXT_PUBLIC_ENVIRONMENT": "production"
  },
  "build": {
    "env": {
      "NEXT_PUBLIC_GA_ID": "@google_analytics_id"
    }
  },
  "crons": [
    {
      "path": "/api/cleanup",
      "schedule": "0 2 * * *"
    }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        }
      ]
    },
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "no-store, must-revalidate"
        }
      ]
    }
  ],
  "redirects": [
    {
      "source": "/dashboard",
      "destination": "/tms-dashboard",
      "permanent": true
    }
  ]
}
```

### GitHub Actions CI/CD流水线
```yaml
# .github/workflows/ci-cd.yml
name: TMS NL-Ops CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18, 20]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run type checking
      run: npm run type-check

    - name: Run unit tests
      run: npm run test:unit
      env:
        CI: true

    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
        REDIS_URL: ${{ secrets.TEST_REDIS_URL }}

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: true

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run npm audit
      run: npm audit --audit-level moderate

    - name: Run Snyk security scan
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, security]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build application
      run: npm run build
      env:
        NEXT_PUBLIC_ENVIRONMENT: production

    - name: Export build
      run: npm run export

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build-artifacts
        path: |
          .next/
          out/

  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, docker-build]
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to Vercel Staging
      uses: vercel/action@v1
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        working-directory: ./

    - name: Run E2E tests on staging
      run: npm run test:e2e:staging
      env:
        BASE_URL: ${{ vars.STAGING_URL }}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, docker-build]
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to Vercel Production
      uses: vercel/action@v1
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        production: true
        working-directory: ./

    - name: Health check
      run: |
        curl -f ${{ vars.PRODUCTION_URL }}/api/health || exit 1
        curl -f ${{ vars.PRODUCTION_URL }}/ || exit 1

  deploy-docker:
    name: Deploy Docker to Production
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy to Kubernetes
      uses: kodermax/kubectl-aws-eks@v1.0.0
      with:
        config: ${{ secrets.KUBE_CONFIG }}
        command: |
          kubectl set image deployment/tms-demo tms-demo=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          kubectl rollout status deployment/tms-demo

    - name: Run production smoke tests
      run: npm run test:smoke
      env:
        BASE_URL: ${{ vars.PRODUCTION_URL }}
```

### Docker配置
```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Environment variable needed for build
ENV NEXT_TELEMETRY_DISABLED=1

RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]

# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/tms
      - REDIS_URL=redis://redis:6379
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - db
      - redis
    networks:
      - tms-network

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=tms
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - tms-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - tms-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    networks:
      - tms-network

volumes:
  postgres_data:
  redis_data:

networks:
  tms-network:
    driver: bridge
```

### Nginx配置
```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:3000;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;

    server {
        listen 80;
        server_name tms-demo.example.com www.tms-demo.example.com;
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name tms-demo.example.com www.tms-demo.example.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';" always;

        # Gzip compression
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_proxied any;
        gzip_comp_level 6;
        gzip_types
            text/plain
            text/css
            text/xml
            text/javascript
            application/javascript
            application/xml+rss
            application/json;

        # Static files
        location /_next/static/ {
            alias /app/.next/static/;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # API endpoints with rate limiting
        location /api/ {
            limit_req zone=api burst=20 nodelay;
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;

            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # Chat endpoint with higher timeout
        location /api/chat {
            limit_req zone=api burst=30 nodelay;
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;

            # Higher timeout for AI responses
            proxy_connect_timeout 120s;
            proxy_send_timeout 120s;
            proxy_read_timeout 120s;
        }

        # Main application
        location / {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # Health check
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
```

### Kubernetes配置
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tms-demo
  labels:
    app: tms-demo
spec:
  replicas: 3
  selector:
    matchLabels:
      app: tms-demo
  template:
    metadata:
      labels:
        app: tms-demo
    spec:
      containers:
      - name: tms-demo
        image: ghcr.io/your-org/tms-demo:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: tms-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: tms-secrets
              key: redis-url
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: tms-secrets
              key: openai-api-key
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: tms-demo-service
spec:
  selector:
    app: tms-demo
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: LoadBalancer
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tms-demo-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
  - hosts:
    - tms-demo.example.com
    secretName: tms-demo-tls
  rules:
  - host: tms-demo.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: tms-demo-service
            port:
              number: 80
```

### 环境配置管理
```bash
# scripts/deploy.sh
#!/bin/bash

set -e

ENVIRONMENT=${1:-staging}
echo "Deploying to $ENVIRONMENT environment"

# 验证环境
case $ENVIRONMENT in
  "staging"|"production")
    echo "Valid environment: $ENVIRONMENT"
    ;;
  *)
    echo "Invalid environment. Use 'staging' or 'production'"
    exit 1
    ;;
esac

# 构建应用
echo "Building application..."
npm run build

# 运行测试
echo "Running tests..."
npm run test:ci

# 部署到Vercel
echo "Deploying to Vercel $ENVIRONMENT..."
if [ "$ENVIRONMENT" = "production" ]; then
  vercel --prod
else
  vercel
fi

# 运行部署后测试
echo "Running post-deployment tests..."
npm run test:e2e:$ENVIRONMENT

# 发送部署通知
echo "Sending deployment notification..."
curl -X POST "$SLACK_WEBHOOK_URL" \
  -H 'Content-type: application/json' \
  --data "{\"text\":\"TMS NL-Ops deployed to $ENVIRONMENT environment successfully\"}"

echo "Deployment completed successfully!"
```

## 交付成果

1. **Vercel配置**: 生产部署配置文件
2. **CI/CD流水线**: GitHub Actions工作流
3. **Docker配置**: 容器化部署配置
4. **Kubernetes配置**: K8s部署配置
5. **Nginx配置**: 反向代理和负载均衡
6. **部署脚本**: 自动化部署脚本
7. **监控配置**: 应用监控和告警配置
8. **安全配置**: SSL证书和安全头部配置

## 验收标准

- [ ] CI/CD流水线运行正常
- [ ] 自动化测试全部通过
- [ ] 代码质量检查通过
- [ ] 安全扫描无高危漏洞
- [ ] 构建和部署时间 < 10分钟
- [ ] 部署成功率 > 95%
- [ ] 回滚机制正常工作
- [ ] 监控告警有效
- [ ] SSL证书配置正确
- [ ] 性能指标满足要求
- [ ] 健康检查正常
- [ ] 日志收集完整

## 相关文件

- `/.github/workflows/ci-cd.yml` - CI/CD流水线
- `/vercel.json` - Vercel配置
- `/Dockerfile` - Docker配置
- `/docker-compose.yml` - Docker Compose配置
- `/nginx.conf` - Nginx配置
- `/k8s/` - Kubernetes配置目录
- `/scripts/deploy.sh` - 部署脚本
- `/scripts/health-check.js` - 健康检查脚本

## 注意事项

1. 环境隔离：严格区分开发和生产环境
2. 安全性：保护好密钥和敏感信息
3. 监控：建立完善的监控体系
4. 备份：定期备份重要数据
5. 测试：部署前必须通过所有测试
6. 文档：详细记录部署过程
7. 回滚：准备快速回滚方案
8. 优化：定期优化部署流程