---
title: Vercel AI SDK v4集成和API网关实现
epic: tms-nlops-demo
task_id: 036
type: task
status: todo
priority: high
tags: ["api", "integration", "vercel", "ai-sdk", "gateway"]
assignee: ""
created: 2025-09-20T04:20:45Z
updated: 2025-09-20T04:20:45Z
parallel: false
depends_on: ["016", "017", "018", "019", "020", "021", "022", "023", "024", "025", "030", "031", "032", "033", "034", "035"]
effort: 4
description: 集成Vercel AI SDK v4，实现API网关，连接LangGraph代理与前端UI
---

## 任务描述

实现基于Vercel AI SDK v4的API网关，作为LangGraph智能代理与前端UI之间的桥梁，支持流式响应、工具调用和状态管理，为TMS NL-Ops演示系统提供统一的AI交互接口。

## 详细需求

### 1. API网关架构设计
- **统一入口**: 提供统一的AI API端点
- **流式处理**: 支持实时流式响应
- **工具集成**: 集成LangGraph工具调用机制
- **状态管理**: 管理对话状态和上下文
- **错误处理**: 完善的错误处理和降级机制

### 2. Vercel AI SDK v4集成
- **核心依赖**: 安装和配置AI SDK v4
- **消息转换**: 实现消息格式转换
- **流式接口**: 实现streamText接口
- **工具调用**: 集成工具调用框架
- **会话管理**: 支持多会话并发

### 3. LangGraph代理集成
- **代理接口**: 封装LangGraph代理调用
- **状态同步**: 实现状态同步机制
- **工具桥接**: 桥接LangGraph工具与AI SDK
- **流式输出**: 支持LangGraph流式输出

### 4. 安全性和性能优化
- **API限流**: 实现请求限流和配额管理
- **认证授权**: 集成身份验证和授权
- **缓存策略**: 实现智能缓存机制
- **监控告警**: 建立性能监控和告警

## 技术实现

### API网关实现
```typescript
// app/api/chat/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText, convertToCoreMessages, CoreMessage } from 'ai';
import { graph } from '@/agent/graph';
import { AgentState } from '@/agent/state';
import { createToolsRegistry } from '@/agent/tools/registry';

export async function POST(req: Request) {
  try {
    const { messages, sessionId } = await req.json();

    // 转换消息格式
    const coreMessages: CoreMessage[] = convertToCoreMessages(messages);

    // 获取或创建会话状态
    const sessionState = await getSessionState(sessionId);

    return streamText({
      model: openai('gpt-4-turbo-preview'),
      messages: coreMessages,
      system: `你是一个智能运输管理助手，帮助用户处理订单、排车、跟踪和回单等业务。`,

      // 自定义工具调用处理
      tools: await createToolsRegistry(sessionState),

      // 工具调用配置
      maxSteps: 5,
      toolChoice: 'auto',

      // 流式处理配置
      streamUsage: true,
      streamEvents: true,

      // 完成回调
      async onFinish({ responseMessages, usage, finishReason }) {
        // 更新会话状态
        await updateSessionState(sessionId, {
          messages: responseMessages,
          usage,
          finishReason,
          timestamp: new Date()
        });

        // 记录分析数据
        await logInteraction(sessionId, {
          inputCount: messages.length,
          outputCount: responseMessages.length,
          toolCalls: responseMessages.flatMap(m => m.tool_calls || []).length,
          duration: Date.now() - sessionState.startTime
        });
      },

      // 错误处理
      onToolError: (error, toolCall) => {
        console.error(`Tool error: ${toolCall.toolName}`, error);
        return {
          type: 'error',
          content: `工具调用失败: ${error.message}`
        };
      }
    });

  } catch (error) {
    console.error('API Gateway error:', error);

    return new Response(JSON.stringify({
      error: '内部服务器错误',
      message: error.message,
      code: 'INTERNAL_ERROR'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// 会话状态管理
async function getSessionState(sessionId: string): Promise<SessionState> {
  // 从Redis或数据库获取会话状态
  const cached = await redis.get(`session:${sessionId}`);
  if (cached) {
    return JSON.parse(cached);
  }

  // 创建新会话
  const newState: SessionState = {
    id: sessionId,
    startTime: Date.now(),
    messages: [],
    context: {
      userRole: 'dispatcher',
      currentTask: undefined
    },
    data: {},
    usage: {
      totalTokens: 0,
      totalCalls: 0
    }
  };

  await redis.setex(`session:${sessionId}`, 3600, JSON.stringify(newState));
  return newState;
}

// 工具注册表
async function createToolsRegistry(sessionState: SessionState) {
  return {
    // 订单管理工具
    queryOrders: {
      description: '查询订单列表',
      parameters: {
        type: 'object',
        properties: {
          customerName: { type: 'string', description: '客户名称' },
          status: { type: 'string', description: '订单状态' },
          dateRange: {
            type: 'object',
            properties: {
              start: { type: 'string', format: 'date-time' },
              end: { type: 'string', format: 'date-time' }
            }
          }
        }
      },
      execute: async (params) => {
        const response = await fetch('/api/tms/orders?' + new URLSearchParams(params));
        return response.json();
      }
    },

    // 其他工具...
  };
}
```

### LangGraph代理桥接
```typescript
// lib/langgraph-bridge.ts
import { graph } from '@/agent/graph';
import { AgentState } from '@/agent/state';
import { streamText } from 'ai';

export class LangGraphBridge {
  async processMessage(
    message: string,
    sessionState: SessionState
  ): Promise<AsyncIterable<any>> {
    // 构建LangGraph输入状态
    const input: Partial<AgentState> = {
      messages: [
        {
          role: 'user',
          content: message,
          timestamp: new Date()
        }
      ],
      context: sessionState.context,
      data: sessionState.data
    };

    // 流式执行LangGraph
    const stream = await graph.stream(input, {
      streamMode: 'values',
      recursionLimit: 10
    });

    return this.transformStream(stream, sessionState);
  }

  private async *transformStream(
    stream: AsyncIterable<any>,
    sessionState: SessionState
  ) {
    for await (const chunk of stream) {
      // 转换LangGraph输出为AI SDK格式
      const transformed = await this.transformChunk(chunk, sessionState);
      if (transformed) {
        yield transformed;
      }
    }
  }

  private async transformChunk(chunk: any, sessionState: SessionState) {
    // 根据chunk类型进行不同的转换
    if (chunk.messages) {
      // 消息类型
      const lastMessage = chunk.messages[chunk.messages.length - 1];
      return {
        type: 'message',
        content: lastMessage.content,
        role: lastMessage.role
      };
    }

    if (chunk.ui) {
      // UI组件类型
      return {
        type: 'tool_call',
        toolName: 'renderUI',
        args: {
          component: chunk.ui.component,
          props: chunk.ui.props
        }
      };
    }

    if (chunk.data) {
      // 数据更新类型
      sessionState.data = { ...sessionState.data, ...chunk.data };
      return {
        type: 'data_update',
        data: chunk.data
      };
    }
  }
}
```

### 中间件和拦截器
```typescript
// lib/api-middleware.ts
import { NextRequest, NextResponse } from 'next/server';

export async function apiMiddleware(req: NextRequest) {
  // 1. 认证检查
  const authHeader = req.headers.get('authorization');
  if (!authHeader || !await validateToken(authHeader)) {
    return NextResponse.json(
      { error: '未授权访问' },
      { status: 401 }
    );
  }

  // 2. 限流检查
  const clientId = await getClientId(req);
  if (!await checkRateLimit(clientId)) {
    return NextResponse.json(
      { error: '请求过于频繁' },
      { status: 429 }
    );
  }

  // 3. 请求日志
  await logRequest(req, clientId);

  // 4. 继续处理
  return NextResponse.next();
}

// 性能监控中间件
export function performanceMiddleware(req: NextRequest) {
  const start = Date.now();

  return async (response: NextResponse) => {
    const duration = Date.now() - start;

    // 记录性能指标
    await recordMetrics({
      endpoint: req.nextUrl.pathname,
      method: req.method,
      duration,
      status: response.status,
      userAgent: req.headers.get('user-agent')
    });

    // 添加性能头
    response.headers.set('X-Response-Time', duration.toString());

    return response;
  };
}
```

## 交付成果

1. **API网关**: 完整的AI API网关实现
2. **Vercel AI SDK集成**: 与AI SDK v4的深度集成
3. **LangGraph桥接**: LangGraph代理与AI SDK的桥接层
4. **中间件**: 认证、限流、监控等中间件
5. **工具注册表**: 动态工具注册和管理
6. **会话管理**: 完整的会话状态管理
7. **监控日志**: 性能监控和日志系统

## 验收标准

- [ ] API网关响应时间 < 500ms
- [ ] 流式响应正常工作，延迟 < 1s
- [ ] 工具调用成功率 > 95%
- [ ] 会话状态管理稳定可靠
- [ ] 限流机制有效防止滥用
- [ ] 认证授权机制完善
- [ ] 性能监控指标准确
- [ ] 错误处理优雅降级
- [ ] 并发处理能力支持100+用户
- [ ] 缓存策略有效减少重复调用
- [ ] 日志记录完整可追溯
- [ ] 代码符合项目编码规范

## 相关文件

- `/app/api/chat/route.ts` - 主API路由
- `/lib/langgraph-bridge.ts` - LangGraph桥接层
- `/lib/api-middleware.ts` - API中间件
- `/lib/session-manager.ts` - 会话管理器
- `/lib/tools-registry.ts` - 工具注册表
- `/lib/performance-monitor.ts` - 性能监控
- `/types/api.ts` - API类型定义

## 注意事项

1. 性能优化：减少不必要的序列化和反序列化
2. 错误处理：提供详细的错误信息和恢复建议
3. 安全性：防止API滥用和数据泄露
4. 可扩展性：支持水平扩展和负载均衡
5. 监控：建立完善的监控和告警体系
6. 版本兼容：考虑AI SDK版本升级的兼容性
7. 测试覆盖：确保高测试覆盖率
8. 文档：提供详细的API文档和使用指南