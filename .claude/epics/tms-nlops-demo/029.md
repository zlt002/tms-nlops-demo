---
title: "TMS NL-Ops演示系统任务029: Agent测试和调试工具"
epic: "tms-nlops-demo"
task: "029"
phase: "4"
status: "pending"
priority: "high"
estimated_hours: 10
parallel: true
depends_on: ["026", "027", "028"]
tags: ["testing", "debugging", "monitoring", "quality-assurance"]
created: "2025-09-20T04:20:45Z"
updated: "2025-09-20T04:20:45Z"
---

## 概述

为TMS NL-Ops演示系统实现完整的Agent测试和调试工具，包括单元测试、集成测试、性能测试、调试面板、日志监控和质量保证机制，确保智能代理系统的稳定性和可靠性。

## 目标

- 实现完整的单元测试套件
- 提供集成测试和端到端测试
- 创建交互式调试工具
- 实现性能监控和基准测试
- 建立质量保证和代码质量检查

## 技术栈

- **测试框架**: Jest + Testing Library
- **调试工具**: Chrome DevTools + 自定义调试面板
- **性能测试**: Benchmark.js + 自定义性能监控
- **日志系统**: Winston + 结构化日志
- **代码质量**: ESLint + Prettier + TypeScript

## 实施步骤

### 1. 创建测试框架和工具集

创建`agent/testing/test-framework.ts`:

```typescript
import { TMSAgentState } from '../types/state-annotations'
import { BaseMessage } from '@langchain/core/messages'
import { StreamEvent } from '../streaming/stream-processor'

export interface TestConfig {
  timeout?: number
  retries?: number
  verbose?: boolean
  collectCoverage?: boolean
  setup?: () => Promise<void>
  teardown?: () => Promise<void>
}

export interface TestResult {
  name: string
  status: 'passed' | 'failed' | 'skipped'
  duration: number
  error?: Error
  coverage?: TestCoverage
  metadata?: Record<string, any>
}

export interface TestCoverage {
  statements: number
  branches: number
  functions: number
  lines: number
  percentage: number
}

export interface TestSuite {
  name: string
  tests: TestCase[]
  beforeAll?: () => Promise<void>
  afterAll?: () => Promise<void>
  beforeEach?: () => Promise<void>
  afterEach?: () => Promise<void>
}

export interface TestCase {
  name: string
  fn: (context: TestContext) => Promise<void> | void
  timeout?: number
  skip?: boolean
  only?: boolean
}

export interface TestContext {
  state: TMSAgentState
  events: StreamEvent[]
  mockTools: Map<string, jest.Mock>
  assert: AssertionHelper
  utils: TestUtilities
}

export class AssertionHelper {
  private results: TestAssertion[] = []

  constructor(private context: TestContext) {}

  async assertTrue(condition: boolean, message?: string): Promise<void> {
    this.results.push({
      type: 'assertTrue',
      condition,
      message,
      passed: condition,
      timestamp: new Date()
    })
    if (!condition) {
      throw new Error(message || 'Assertion failed: expected true')
    }
  }

  async assertEquals(actual: any, expected: any, message?: string): Promise<void> {
    const passed = JSON.stringify(actual) === JSON.stringify(expected)
    this.results.push({
      type: 'assertEquals',
      actual,
      expected,
      message,
      passed,
      timestamp: new Date()
    })
    if (!passed) {
      throw new Error(message || `Assertion failed: expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`)
    }
  }

  async assertThrows(fn: () => Promise<any>, expectedError?: string | RegExp): Promise<void> {
    try {
      await fn()
      this.results.push({
        type: 'assertThrows',
        error: null,
        message: 'Expected function to throw',
        passed: false,
        timestamp: new Date()
      })
      throw new Error('Expected function to throw')
    } catch (error) {
      const passed = expectedError ?
        (typeof expectedError === 'string' ? error.message === expectedError : expectedError.test(error.message)) :
        true
      this.results.push({
        type: 'assertThrows',
        error: error.message,
        expectedError,
        passed,
        timestamp: new Date()
      })
      if (!passed) {
        throw new Error(`Assertion failed: expected error to match ${expectedError}, got ${error.message}`)
      }
    }
  }

  async assertContains(haystack: any[], needle: any, message?: string): Promise<void> {
    const passed = haystack.includes(needle)
    this.results.push({
      type: 'assertContains',
      haystack,
      needle,
      message,
      passed,
      timestamp: new Date()
    })
    if (!passed) {
      throw new Error(message || `Assertion failed: expected ${JSON.stringify(haystack)} to contain ${JSON.stringify(needle)}`)
    }
  }

  getResults(): TestAssertion[] {
    return this.results
  }
}

export interface TestAssertion {
  type: string
  condition?: boolean
  actual?: any
  expected?: any
  message?: string
  error?: string
  expectedError?: string | RegExp
  haystack?: any[]
  needle?: any
  passed: boolean
  timestamp: Date
}

export class TestUtilities {
  static generateMockState(overrides: Partial<TMSAgentState> = {}): TMSAgentState {
    return {
      messages: [],
      context: {
        userRole: 'customer',
        currentTask: '',
        taskHistory: [],
        intent: '',
        entities: {},
        session: {
          id: `test_${Date.now()}`,
          startTime: new Date(),
          lastActivity: new Date(),
          metadata: {}
        }
      },
      data: {
        orders: [],
        vehicles: [],
        dispatch: null,
        tracking: [],
        pod: null,
        customers: [],
        results: {},
        cache: {}
      },
      ui: {
        component: '',
        props: {},
        layout: 'vertical',
        actions: [],
        loading: false,
        error: '',
        timestamp: new Date()
      },
      metadata: {
        startTime: new Date(),
        stepCount: 0,
        toolCalls: [],
        errors: [],
        performance: {
          totalTime: 0,
          toolExecutionTime: 0,
          llmCalls: 0,
          tokenUsage: { prompt: 0, completion: 0, total: 0 },
          memoryUsage: { used: 0, total: 0, percentage: 0 }
        },
        checkpoint: {
          id: '',
          timestamp: new Date(),
          version: '1.0.0'
        }
      },
      ...overrides
    }
  }

  static generateMockMessage(role: string, content: string): BaseMessage {
    return {
      role: role as any,
      content,
      timestamp: new Date()
    } as BaseMessage
  }

  static generateMockEvent(type: StreamEvent['type'], data: any): StreamEvent {
    return {
      id: `test_${Date.now()}_${Math.random()}`,
      type,
      data,
      timestamp: new Date()
    }
  }

  static async waitFor<T>(
    condition: () => Promise<T> | T,
    timeout: number = 5000,
    interval: number = 100
  ): Promise<T> {
    const startTime = Date.now()

    while (Date.now() - startTime < timeout) {
      try {
        const result = await condition()
        return result
      } catch (error) {
        await new Promise(resolve => setTimeout(resolve, interval))
      }
    }

    throw new Error(`Timeout waiting for condition after ${timeout}ms`)
  }

  static async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  static generateTestMessages(count: number = 5): BaseMessage[] {
    const messages: BaseMessage[] = []
    const roles = ['user', 'assistant', 'tool']
    const contents = [
      '查询订单信息',
      '创建新的运输订单',
      '跟踪车辆位置',
      '上传回单',
      '生成业务报告'
    ]

    for (let i = 0; i < count; i++) {
      messages.push(this.generateMockMessage(
        roles[i % roles.length],
        contents[i % contents.length]
      ))
    }

    return messages
  }
}

export class TestRunner {
  private suites: TestSuite[] = []
  private results: TestResult[] = []
  private config: TestConfig

  constructor(config: TestConfig = {}) {
    this.config = {
      timeout: 5000,
      retries: 1,
      verbose: false,
      collectCoverage: false,
      ...config
    }
  }

  addSuite(suite: TestSuite): void {
    this.suites.push(suite)
  }

  async run(): Promise<TestResult[]> {
    this.results = []

    if (this.config.setup) {
      await this.config.setup()
    }

    for (const suite of this.suites) {
      await this.runSuite(suite)
    }

    if (this.config.teardown) {
      await this.config.teardown()
    }

    return this.results
  }

  private async runSuite(suite: TestSuite): Promise<void> {
    if (this.config.verbose) {
      console.log(`\nRunning suite: ${suite.name}`)
    }

    if (suite.beforeAll) {
      await suite.beforeAll()
    }

    for (const test of suite.tests) {
      if (test.skip) {
        this.results.push({
          name: `${suite.name} - ${test.name}`,
          status: 'skipped',
          duration: 0
        })
        continue
      }

      const startTime = Date.now()

      try {
        if (suite.beforeEach) {
          await suite.beforeEach()
        }

        await this.runTest(suite, test)

        if (suite.afterEach) {
          await suite.afterEach()
        }

        this.results.push({
          name: `${suite.name} - ${test.name}`,
          status: 'passed',
          duration: Date.now() - startTime
        })

      } catch (error) {
        if (suite.afterEach) {
          try {
            await suite.afterEach()
          } catch (cleanupError) {
            console.error('Cleanup error:', cleanupError)
          }
        }

        this.results.push({
          name: `${suite.name} - ${test.name}`,
          status: 'failed',
          duration: Date.now() - startTime,
          error: error as Error
        })
      }
    }

    if (suite.afterAll) {
      await suite.afterAll()
    }
  }

  private async runTest(suite: TestSuite, test: TestCase): Promise<void> {
    const context: TestContext = {
      state: TestUtilities.generateMockState(),
      events: [],
      mockTools: new Map(),
      assert: new AssertionHelper({} as TestContext),
      utils: TestUtilities
    }

    const timeout = test.timeout || this.config.timeout

    await Promise.race([
      test.fn(context),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error(`Test timed out after ${timeout}ms`)), timeout)
      )
    ])
  }

  getResults(): TestResult[] {
    return this.results
  }

  getSummary(): {
    total: number
    passed: number
    failed: number
    skipped: number
    successRate: number
    totalDuration: number
  } {
    const total = this.results.length
    const passed = this.results.filter(r => r.status === 'passed').length
    const failed = this.results.filter(r => r.status === 'failed').length
    const skipped = this.results.filter(r => r.status === 'skipped').length
    const successRate = total > 0 ? (passed / total) * 100 : 0
    const totalDuration = this.results.reduce((sum, r) => sum + r.duration, 0)

    return {
      total,
      passed,
      failed,
      skipped,
      successRate,
      totalDuration
    }
  }
}

// 创建测试运行器实例
export function createTestRunner(config?: TestConfig): TestRunner {
  return new TestRunner(config)
}
```

### 2. 创建单元测试套件

创建`agent/tests/unit/supervisor-node.test.ts`:

```typescript
import { SupervisorNode, createSupervisorNode } from '../../nodes/supervisor-node'
import { TestRunner, TestUtilities } from '../test-framework'
import { ChatOpenAI } from '@langchain/openai'
import { BaseMessage } from '@langchain/core/messages'

describe('SupervisorNode', () => {
  let supervisorNode: SupervisorNode
  let mockLLM: jest.Mocked<ChatOpenAI>

  beforeEach(() => {
    mockLLM = {
      invoke: jest.fn(),
      stream: jest.fn()
    } as any

    supervisorNode = createSupervisorNode(mockLLM)
  })

  describe('基础功能测试', () => {
    test('应该正确创建Supervisor节点实例', () => {
      expect(supervisorNode).toBeInstanceOf(SupervisorNode)
      expect(typeof supervisorNode.invoke).toBe('function')
      expect(typeof supervisorNode.getStats).toBe('function')
    })

    test('应该返回正确的节点统计信息', () => {
      const stats = supervisorNode.getStats()
      expect(stats).toEqual({
        totalCalls: 0,
        averageExecutionTime: 0,
        strategyUsage: {},
        errorRate: 0
      })
    })
  })

  describe('用户角色处理测试', () => {
    test('应该正确处理不同用户角色的配置', async () => {
      const testState = TestUtilities.generateMockState({
        context: {
          ...TestUtilities.generateMockState().context,
          userRole: 'dispatcher'
        }
      })

      // 这里应该测试Supervisor节点如何根据用户角色调整行为
      // 由于涉及真实的LLM调用，这里只是测试框架的用法
      expect(testState.context.userRole).toBe('dispatcher')
    })

    test('应该为不同角色提供不同的工具权限', () => {
      const roles = ['dispatcher', 'customer_service', 'manager', 'customer']

      for (const role of roles) {
        const state = TestUtilities.generateMockState({
          context: {
            ...TestUtilities.generateMockState().context,
            userRole: role
          }
        })

        expect(state.context.userRole).toBe(role)
      }
    })
  })

  describe('决策策略测试', () => {
    test('应该正确选择直接工具调用策略', () => {
      const state = TestUtilities.generateMockState({
        messages: [
          TestUtilities.generateMockMessage('user', '查询订单123的状态')
        ]
      })

      // 测试策略选择逻辑
      const lastMessage = state.messages[state.messages.length - 1]
      expect(lastMessage.content).toBe('查询订单123的状态')

      // 这里应该测试策略选择的结果
      // 由于策略选择逻辑在SupervisorNode内部，这里只是演示测试框架
    })

    test('应该正确选择多步骤工作流策略', () => {
      const state = TestUtilities.generateMockState({
        messages: [
          TestUtilities.generateMockMessage('user', '创建一个新的运输订单')
        ]
      })

      const lastMessage = state.messages[state.messages.length - 1]
      expect(lastMessage.content).toBe('创建一个新的运输订单')
    })

    test('应该正确选择分析和报告策略', () => {
      const state = TestUtilities.generateMockState({
        messages: [
          TestUtilities.generateMockMessage('user', '分析本月的运输数据并生成报告')
        ]
      })

      const lastMessage = state.messages[state.messages.length - 1]
      expect(lastMessage.content).toBe('分析本月的运输数据并生成报告')
    })
  })

  describe('错误处理测试', () => {
    test('应该正确处理LLM调用错误', async () => {
      mockLLM.invoke.mockRejectedValue(new Error('LLM调用失败'))

      const state = TestUtilities.generateMockState({
        messages: [
          TestUtilities.generateMockMessage('user', '测试消息')
        ]
      })

      // 这里应该测试错误处理逻辑
      // 由于涉及真实的SupervisorNode实现，这里只是演示测试框架
      expect(mockLLM.invoke).toHaveBeenCalled()
    })

    test('应该正确处理工具调用错误', async () => {
      // 测试工具调用错误的处理
      const state = TestUtilities.generateMockState()

      // 模拟工具调用错误的情况
      expect(true).toBe(true) // 占位符测试
    })
  })

  describe('性能测试', () => {
    test('应该在合理时间内完成处理', async () => {
      const state = TestUtilities.generateMockState({
        messages: TestUtilities.generateTestMessages(10)
      })

      const startTime = Date.now()

      // 这里应该测试SupervisorNode的处理时间
      // 由于涉及真实的处理逻辑，这里只是演示测试框架

      const duration = Date.now() - startTime
      expect(duration).toBeLessThan(10000) // 10秒内完成
    })

    test('应该正确统计性能指标', () => {
      const stats = supervisorNode.getStats()
      expect(typeof stats.totalCalls).toBe('number')
      expect(typeof stats.averageExecutionTime).toBe('number')
      expect(typeof stats.errorRate).toBe('number')
    })
  })
})
```

### 3. 创建集成测试套件

创建`agent/tests/integration/workflow-integration.test.ts`:

```typescript
import { TMSWorkflow, WorkflowFactory } from '../../graph/workflow-definition'
import { WorkflowExecutor } from '../../graph/workflow-executor'
import { TestUtilities } from '../test-framework'
import { TMSAgentState } from '../../types/state-annotations'

describe('工作流集成测试', () => {
  let workflow: TMSWorkflow
  let executor: WorkflowExecutor

  beforeEach(() => {
    workflow = WorkflowFactory.createWithDefaults()
    executor = new WorkflowExecutor(workflow)
  })

  describe('完整工作流测试', () => {
    test('应该完整处理订单查询工作流', async () => {
      const initialState: Partial<TMSAgentState> = {
        messages: [
          TestUtilities.generateMockMessage('user', '查询最近的订单')
        ],
        context: {
          userRole: 'customer_service',
          currentTask: 'query_orders',
          taskHistory: [],
          intent: 'query_orders',
          entities: {},
          session: {
            id: `test_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: {}
          }
        }
      }

      const result = await executor.execute(initialState, {
        timeout: 30000,
        recursionLimit: 5
      })

      expect(result.success).toBe(true)
      expect(result.finalState).toBeDefined()
      expect(result.executionTime).toBeGreaterThan(0)
    })

    test('应该完整处理订单创建工作流', async () => {
      const initialState: Partial<TMSAgentState> = {
        messages: [
          TestUtilities.generateMockMessage('user', '创建一个从北京到上海的运输订单')
        ],
        context: {
          userRole: 'dispatcher',
          currentTask: 'create_order',
          taskHistory: [],
          intent: 'create_order',
          entities: {
            origin: '北京',
            destination: '上海'
          },
          session: {
            id: `test_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: {}
          }
        }
      }

      const result = await executor.execute(initialState, {
        timeout: 45000,
        recursionLimit: 8
      })

      expect(result.success).toBe(true)
      expect(result.finalState).toBeDefined()
      expect(result.stats.toolCalls).toBeGreaterThan(0)
    })

    test('应该完整处理车辆跟踪工作流', async () => {
      const initialState: Partial<TMSAgentState> = {
        messages: [
          TestUtilities.generateMockMessage('user', '跟踪车牌号京A12345的车辆位置')
        ],
        context: {
          userRole: 'dispatcher',
          currentTask: 'track_vehicle',
          taskHistory: [],
          intent: 'track_vehicle',
          entities: {
            plateNumber: '京A12345'
          },
          session: {
            id: `test_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: {}
          }
        }
      }

      const result = await executor.execute(initialState, {
        timeout: 30000,
        recursionLimit: 5
      })

      expect(result.success).toBe(true)
      expect(result.finalState).toBeDefined()
    })
  })

  describe('错误恢复测试', () => {
    test('应该在工具调用失败后优雅恢复', async () => {
      const initialState: Partial<TMSAgentState> = {
        messages: [
          TestUtilities.generateMockMessage('user', '查询不存在的订单999999')
        ],
        context: {
          userRole: 'customer',
          currentTask: 'query_orders',
          taskHistory: [],
          intent: 'query_orders',
          entities: {
            orderNumber: '999999'
          },
          session: {
            id: `test_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: {}
          }
        }
      }

      const result = await executor.execute(initialState, {
        timeout: 30000,
        recursionLimit: 5
      })

      expect(result.success).toBe(true)
      expect(result.finalState).toBeDefined()
      // 应该包含错误处理和用户友好的错误消息
    })

    test('应该在网络错误后重试', async () => {
      const initialState: Partial<TMSAgentState> = {
        messages: [
          TestUtilities.generateMockMessage('user', '创建订单测试')
        ],
        context: {
          userRole: 'dispatcher',
          currentTask: 'create_order',
          taskHistory: [],
          intent: 'create_order',
          entities: {},
          session: {
            id: `test_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: { simulateNetworkError: true }
          }
        }
      }

      const result = await executor.executeWithRetry(initialState, {
        timeout: 60000,
        maxRetries: 3
      })

      expect(result).toBeDefined()
      // 应该测试重试逻辑
    })
  })

  describe('性能测试', () => {
    test('应该在性能限制内完成处理', async () => {
      const initialState: Partial<TMSAgentState> = {
        messages: TestUtilities.generateTestMessages(5),
        context: {
          userRole: 'manager',
          currentTask: 'generate_report',
          taskHistory: [],
          intent: 'generate_report',
          entities: {},
          session: {
            id: `test_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: {}
          }
        }
      }

      const result = await executor.execute(initialState, {
        timeout: 60000,
        recursionLimit: 10
      })

      expect(result.success).toBe(true)
      expect(result.executionTime).toBeLessThan(30000) // 30秒内完成
      expect(result.stats.totalSteps).toBeLessThan(20)
    })

    test('应该正确处理大批量请求', async () => {
      const requests: Partial<TMSAgentState>[] = []

      for (let i = 0; i < 10; i++) {
        requests.push({
          messages: [
            TestUtilities.generateMockMessage('user', `批量测试请求${i}`)
          ],
          context: {
            userRole: 'customer',
            currentTask: 'general_conversation',
            taskHistory: [],
            intent: 'general_conversation',
            entities: {},
            session: {
              id: `test_batch_${i}`,
              startTime: new Date(),
              lastActivity: new Date(),
              metadata: {}
            }
          }
        })
      }

      const startTime = Date.now()
      const results = await executor.batchExecute(requests, {
        timeout: 30000
      })
      const totalTime = Date.now() - startTime

      expect(results.length).toBe(10)
      expect(results.every(r => r.success)).toBe(true)
      expect(totalTime).toBeLessThan(60000) // 60秒内完成所有请求
    })
  })

  describe('状态管理测试', () => {
    test('应该正确维护状态一致性', async () => {
      const initialState: Partial<TMSAgentState> = {
        messages: [
          TestUtilities.generateMockMessage('user', '多步骤状态测试')
        ],
        context: {
          userRole: 'dispatcher',
          currentTask: 'multi_step',
          taskHistory: [],
          intent: 'multi_step',
          entities: {},
          session: {
            id: `test_state_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: {}
          }
        }
      }

      const result = await executor.execute(initialState, {
        timeout: 45000,
        recursionLimit: 8
      })

      expect(result.success).toBe(true)
      expect(result.finalState).toBeDefined()

      // 验证状态一致性
      const finalState = result.finalState!
      expect(finalState.metadata.stepCount).toBeGreaterThan(0)
      expect(finalState.context.taskHistory.length).toBeGreaterThan(0)
      expect(finalState.messages.length).toBeGreaterThan(1)
    })

    test('应该正确处理并发请求', async () => {
      const concurrentRequests = 3
      const promises: Promise<any>[] = []

      for (let i = 0; i < concurrentRequests; i++) {
        const initialState: Partial<TMSAgentState> = {
          messages: [
            TestUtilities.generateMockMessage('user', `并发测试${i}`)
          ],
          context: {
            userRole: 'customer',
            currentTask: 'concurrent_test',
            taskHistory: [],
            intent: 'concurrent_test',
            entities: {},
            session: {
              id: `test_concurrent_${i}`,
              startTime: new Date(),
              lastActivity: new Date(),
              metadata: {}
            }
          }
        }

        promises.push(executor.execute(initialState, {
          timeout: 30000
        }))
      }

      const results = await Promise.all(promises)

      expect(results.length).toBe(concurrentRequests)
      expect(results.every(r => r.success)).toBe(true)

      // 验证每个请求都有独立的session
      const sessionIds = results.map(r => r.finalState!.context.session.id)
      expect(new Set(sessionIds).size).toBe(concurrentRequests)
    })
  })
})
```

### 4. 创建性能测试套件

创建`agent/tests/performance/performance.test.ts`:

```typescript
import { TMSWorkflow, WorkflowFactory } from '../../graph/workflow-definition'
import { WorkflowExecutor } from '../../graph/workflow-executor'
import { TestUtilities } from '../test-framework'
import { Benchmark } from 'benchmark'

describe('性能测试', () => {
  let workflow: TMSWorkflow
  let executor: WorkflowExecutor
  let suite: Benchmark.Suite

  beforeEach(() => {
    workflow = WorkflowFactory.createWithDefaults()
    executor = new WorkflowExecutor(workflow)

    suite = new Benchmark.Suite()
  })

  describe('基准测试', () => {
    test('Supervisor节点处理性能', (done) => {
      const initialState = TestUtilities.generateMockState({
        messages: TestUtilities.generateTestMessages(1)
      })

      suite
        .add('Supervisor节点处理', {
          defer: true,
          fn: (deferred: any) => {
            executor.execute(initialState)
              .then(() => deferred.resolve())
              .catch(deferred.reject)
          }
        })
        .on('cycle', (event: any) => {
          console.log(String(event.target))
          const ops = event.target.hz
          expect(ops).toBeGreaterThan(1) // 每秒至少处理1个请求
        })
        .on('complete', () => done())
        .run({ async: true })
    })

    test('工作流编译性能', (done) => {
      suite
        .add('工作流编译', () => {
          const workflow = WorkflowFactory.createWithDefaults()
          workflow.compile()
        })
        .on('cycle', (event: any) => {
          console.log(String(event.target))
          const ops = event.target.hz
          expect(ops).toBeGreaterThan(10) // 每秒至少编译10次
        })
        .on('complete', () => done())
        .run()
    })

    test('状态更新性能', (done) => {
      suite
        .add('状态更新', () => {
          const state = TestUtilities.generateMockState()
          state.metadata.stepCount++
          state.messages.push(TestUtilities.generateMockMessage('user', '测试'))
        })
        .on('cycle', (event: any) => {
          console.log(String(event.target))
          const ops = event.target.hz
          expect(ops).toBeGreaterThan(10000) // 每秒至少更新10000次状态
        })
        .on('complete', () => done())
        .run()
    })
  })

  describe('内存使用测试', () => {
    test('应该控制内存使用在合理范围内', async () => {
      const initialMemory = process.memoryUsage()
      const requests: any[] = []

      // 模拟大量请求
      for (let i = 0; i < 100; i++) {
        const initialState: Partial<any> = {
          messages: [
            TestUtilities.generateMockMessage('user', `内存测试${i}`)
          ],
          context: {
            userRole: 'customer',
            session: { id: `mem_test_${i}`, startTime: new Date(), lastActivity: new Date(), metadata: {} },
            currentTask: 'memory_test',
            taskHistory: [],
            intent: 'memory_test',
            entities: {}
          }
        }

        requests.push(executor.execute(initialState, { timeout: 10000 }))
      }

      await Promise.all(requests)

      // 等待垃圾回收
      await new Promise(resolve => setTimeout(resolve, 1000))

      const finalMemory = process.memoryUsage()
      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed
      const memoryIncreaseMB = memoryIncrease / (1024 * 1024)

      console.log(`内存增加: ${memoryIncreaseMB.toFixed(2)}MB`)
      expect(memoryIncreaseMB).toBeLessThan(100) // 内存增加不超过100MB
    })

    test('应该正确处理长时间运行的会话', async () => {
      const initialState: Partial<any> = {
        messages: [],
        context: {
          userRole: 'manager',
          session: {
            id: `long_running_${Date.now()}`,
            startTime: new Date(),
            lastActivity: new Date(),
            metadata: {}
          },
          currentTask: 'long_running_test',
          taskHistory: [],
          intent: 'long_running_test',
          entities: {}
        }
      }

      const startTime = Date.now()
      const duration = 30000 // 30秒

      // 模拟长时间运行的会话
      while (Date.now() - startTime < duration) {
        initialState.messages!.push(TestUtilities.generateMockMessage('user', `长时间测试${Date.now()}`))

        try {
          await executor.execute(initialState, { timeout: 5000 })
        } catch (error) {
          // 忽略超时错误
        }

        await new Promise(resolve => setTimeout(resolve, 1000))
      }

      const memoryUsage = process.memoryUsage()
      const memoryUsageMB = memoryUsage.heapUsed / (1024 * 1024)

      console.log(`长时间运行后内存使用: ${memoryUsageMB.toFixed(2)}MB`)
      expect(memoryUsageMB).toBeLessThan(200) // 内存使用不超过200MB
    })
  })

  describe('并发性能测试', () => {
    test('应该正确处理高并发请求', async () => {
      const concurrentLevels = [1, 5, 10, 20, 50]
      const results: any[] = []

      for (const level of concurrentLevels) {
        const requests: any[] = []
        const startTime = Date.now()

        for (let i = 0; i < level; i++) {
          const initialState: Partial<any> = {
            messages: [
              TestUtilities.generateMockMessage('user', `并发测试${i}`)
            ],
            context: {
              userRole: 'customer',
              session: { id: `concurrent_${level}_${i}`, startTime: new Date(), lastActivity: new Date(), metadata: {} },
              currentTask: 'concurrent_test',
              taskHistory: [],
              intent: 'concurrent_test',
              entities: {}
            }
          }

          requests.push(executor.execute(initialState, { timeout: 15000 }))
        }

        try {
          const levelResults = await Promise.all(requests)
          const totalTime = Date.now() - startTime
          const successRate = levelResults.filter(r => r.success).length / level

          results.push({
            concurrentLevel: level,
            totalTime,
            successRate,
            avgTimePerRequest: totalTime / level
          })

          console.log(`并发级别 ${level}: 总时间 ${totalTime}ms, 成功率 ${(successRate * 100).toFixed(1)}%`)
        } catch (error) {
          console.error(`并发级别 ${level} 测试失败:`, error)
        }
      }

      // 验证性能趋势
      expect(results.length).toBe(concurrentLevels.length)

      // 随着并发级别增加，总时间应该增长，但不是线性增长
      for (let i = 1; i < results.length; i++) {
        const current = results[i]
        const previous = results[i - 1]

        expect(current.successRate).toBeGreaterThan(0.8) // 成功率至少80%
        expect(current.totalTime).toBeGreaterThan(0)
      }
    })

    test('应该正确处理请求队列', async () => {
      const queueSize = 100
      const batchSize = 10
      const results: any[] = []

      for (let batch = 0; batch < queueSize / batchSize; batch++) {
        const batchRequests: any[] = []

        for (let i = 0; i < batchSize; i++) {
          const initialState: Partial<any> = {
            messages: [
              TestUtilities.generateMockMessage('user', `队列测试${batch}_${i}`)
            ],
            context: {
              userRole: 'customer',
              session: { id: `queue_${batch}_${i}`, startTime: new Date(), lastActivity: new Date(), metadata: {} },
              currentTask: 'queue_test',
              taskHistory: [],
              intent: 'queue_test',
              entities: {}
            }
          }

          batchRequests.push(executor.execute(initialState, { timeout: 10000 }))
        }

        const batchResults = await Promise.all(batchRequests)
        results.push(...batchResults)

        // 批次间添加延迟
        await new Promise(resolve => setTimeout(resolve, 100))
      }

      expect(results.length).toBe(queueSize)
      const successRate = results.filter(r => r.success).length / queueSize
      expect(successRate).toBeGreaterThan(0.9) // 队列处理成功率90%以上
    })
  })

  describe('稳定性测试', () => {
    test('应该在长时间运行下保持稳定', async () => {
      const testDuration = 60000 // 1分钟
      const requestInterval = 1000 // 每秒1个请求
      const results: any[] = []
      const startTime = Date.now()

      const runTest = async () => {
        if (Date.now() - startTime >= testDuration) return

        const initialState: Partial<any> = {
          messages: [
            TestUtilities.generateMockMessage('user', `稳定性测试${Date.now()}`)
          ],
          context: {
            userRole: 'customer',
            session: { id: `stability_${Date.now()}`, startTime: new Date(), lastActivity: new Date(), metadata: {} },
            currentTask: 'stability_test',
            taskHistory: [],
            intent: 'stability_test',
            entities: {}
          }
        }

        try {
          const result = await executor.execute(initialState, { timeout: 5000 })
          results.push(result)
        } catch (error) {
          console.error('稳定性测试错误:', error)
        }

        setTimeout(runTest, requestInterval)
      }

      await runTest()

      // 等待所有测试完成
      await new Promise(resolve => setTimeout(resolve, 5000))

      const successRate = results.filter(r => r.success).length / results.length
      const avgResponseTime = results.reduce((sum, r) => sum + r.executionTime, 0) / results.length

      console.log(`稳定性测试结果: 成功率 ${(successRate * 100).toFixed(1)}%, 平均响应时间 ${avgResponseTime.toFixed(0)}ms`)

      expect(successRate).toBeGreaterThan(0.95) // 稳定性测试成功率95%以上
      expect(avgResponseTime).toBeLessThan(3000) // 平均响应时间3秒以内
    })

    test('应该正确处理资源回收', async () => {
      const iterations = 50
      const memorySnapshots: number[] = []

      for (let i = 0; i < iterations; i++) {
        const initialState: Partial<any> = {
          messages: [
            TestUtilities.generateMockMessage('user', `资源回收测试${i}`)
          ],
          context: {
            userRole: 'customer',
            session: { id: `resource_${i}`, startTime: new Date(), lastActivity: new Date(), metadata: {} },
            currentTask: 'resource_test',
            taskHistory: [],
            intent: 'resource_test',
            entities: {}
          }
        }

        await executor.execute(initialState, { timeout: 5000 })

        // 定期记录内存使用
        if (i % 10 === 0) {
          memorySnapshots.push(process.memoryUsage().heapUsed)
        }
      }

      // 验证内存使用没有持续增长
      const maxMemory = Math.max(...memorySnapshots)
      const minMemory = Math.min(...memorySnapshots)
      const memoryGrowth = maxMemory - minMemory
      const memoryGrowthMB = memoryGrowth / (1024 * 1024)

      console.log(`内存增长: ${memoryGrowthMB.toFixed(2)}MB`)
      expect(memoryGrowthMB).toBeLessThan(50) // 内存增长不超过50MB
    })
  })
})
```

### 5. 创建调试工具

创建`agent/debugging/debug-panel.tsx`:

```typescript
import React, { useState, useEffect } from 'react'
import { TMSAgentState } from '../types/state-annotations'
import { StreamEvent } from '../streaming/stream-processor'

interface DebugPanelProps {
  visible: boolean
  onClose: () => void
  state?: TMSAgentState
  events?: StreamEvent[]
  onAction?: (action: string, data: any) => void
}

export const DebugPanel: React.FC<DebugPanelProps> = ({
  visible,
  onClose,
  state,
  events = [],
  onAction
}) => {
  const [activeTab, setActiveTab] = useState<'state' | 'events' | 'tools' | 'performance'>('state')
  const [filteredEvents, setFilteredEvents] = useState<StreamEvent[]>([])
  const [eventFilter, setEventFilter] = useState<string>('')
  const [expandedState, setExpandedState] = useState<Record<string, boolean>>({})

  useEffect(() => {
    if (eventFilter) {
      setFilteredEvents(events.filter(event =>
        event.type.toLowerCase().includes(eventFilter.toLowerCase()) ||
        JSON.stringify(event.data).toLowerCase().includes(eventFilter.toLowerCase())
      ))
    } else {
      setFilteredEvents(events)
    }
  }, [events, eventFilter])

  const formatTimestamp = (timestamp: Date): string => {
    return new Date(timestamp).toLocaleTimeString()
  }

  const formatMemory = (bytes: number): string => {
    return `${(bytes / 1024 / 1024).toFixed(2)}MB`
  }

  const toggleStateExpansion = (path: string): void => {
    setExpandedState(prev => ({
      ...prev,
      [path]: !prev[path]
    }))
  }

  const renderStateValue = (key: string, value: any, path: string = ''): React.ReactNode => {
    const currentPath = path ? `${path}.${key}` : key
    const isExpanded = expandedState[currentPath]

    if (value === null || value === undefined) {
      return <span className="text-gray-500">{String(value)}</span>
    }

    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
      return <span className="text-blue-600">{String(value)}</span>
    }

    if (Array.isArray(value)) {
      return (
        <div className="ml-4">
          <button
            onClick={() => toggleStateExpansion(currentPath)}
            className="text-xs text-gray-500 hover:text-gray-700"
          >
            {isExpanded ? '▼' : '▶'} Array({value.length})
          </button>
          {isExpanded && (
            <div className="border-l border-gray-300 ml-2 pl-2">
              {value.map((item, index) => (
                <div key={index} className="text-xs">
                  <span className="text-gray-500">[{index}]:</span>
                  {renderStateValue(String(index), item, currentPath)}
                </div>
              ))}
            </div>
          )}
        </div>
      )
    }

    if (typeof value === 'object') {
      return (
        <div className="ml-4">
          <button
            onClick={() => toggleStateExpansion(currentPath)}
            className="text-xs text-gray-500 hover:text-gray-700"
          >
            {isExpanded ? '▼' : '▶'} Object
          </button>
          {isExpanded && (
            <div className="border-l border-gray-300 ml-2 pl-2">
              {Object.entries(value).map(([k, v]) => (
                <div key={k} className="text-xs">
                  <span className="text-gray-500">{k}:</span>
                  {renderStateValue(k, v, currentPath)}
                </div>
              ))}
            </div>
          )}
        </div>
      )
    }

    return <span className="text-gray-600">{String(value)}</span>
  }

  if (!visible) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-6xl h-full max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b">
          <h2 className="text-xl font-bold">调试面板</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700"
          >
            ✕
          </button>
        </div>

        {/* Tabs */}
        <div className="flex border-b">
          {[
            { id: 'state', label: '状态' },
            { id: 'events', label: '事件' },
            { id: 'tools', label: '工具' },
            { id: 'performance', label: '性能' }
          ].map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id as any)}
              className={`px-4 py-2 text-sm font-medium ${
                activeTab === tab.id
                  ? 'text-blue-600 border-b-2 border-blue-600'
                  : 'text-gray-500 hover:text-gray-700'
              }`}
            >
              {tab.label}
            </button>
          ))}
        </div>

        {/* Content */}
        <div className="flex-1 overflow-auto">
          {activeTab === 'state' && state && (
            <div className="p-4">
              <h3 className="text-lg font-semibold mb-4">当前状态</h3>
              <div className="space-y-4">
                <div>
                  <h4 className="font-medium text-gray-700 mb-2">消息</h4>
                  <div className="bg-gray-50 p-3 rounded max-h-32 overflow-y-auto">
                    {state.messages.map((msg, index) => (
                      <div key={index} className="text-sm mb-2">
                        <span className="text-gray-500">{msg.role}:</span>
                        <span className="ml-2">{msg.content}</span>
                      </div>
                    ))}
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-gray-700 mb-2">上下文</h4>
                  <div className="bg-gray-50 p-3 rounded">
                    {renderStateValue('context', state.context)}
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-gray-700 mb-2">UI</h4>
                  <div className="bg-gray-50 p-3 rounded">
                    {renderStateValue('ui', state.ui)}
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-gray-700 mb-2">元数据</h4>
                  <div className="bg-gray-50 p-3 rounded">
                    {renderStateValue('metadata', state.metadata)}
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'events' && (
            <div className="p-4">
              <div className="flex items-center mb-4">
                <h3 className="text-lg font-semibold mr-4">事件流</h3>
                <input
                  type="text"
                  placeholder="过滤事件..."
                  value={eventFilter}
                  onChange={(e) => setEventFilter(e.target.value)}
                  className="px-3 py-1 border rounded text-sm"
                />
              </div>
              <div className="space-y-2 max-h-96 overflow-y-auto">
                {filteredEvents.map((event, index) => (
                  <div key={index} className="bg-gray-50 p-3 rounded text-sm">
                    <div className="flex items-center justify-between mb-1">
                      <span className="font-medium text-blue-600">{event.type}</span>
                      <span className="text-gray-500 text-xs">
                        {formatTimestamp(event.timestamp)}
                      </span>
                    </div>
                    <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
                      {JSON.stringify(event.data, null, 2)}
                    </pre>
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'tools' && state && (
            <div className="p-4">
              <h3 className="text-lg font-semibold mb-4">工具调用</h3>
              <div className="space-y-4">
                <div>
                  <h4 className="font-medium text-gray-700 mb-2">调用历史</h4>
                  <div className="bg-gray-50 p-3 rounded max-h-48 overflow-y-auto">
                    {state.metadata.toolCalls.length === 0 ? (
                      <p className="text-gray-500 text-sm">暂无工具调用</p>
                    ) : (
                      state.metadata.toolCalls.map((call, index) => (
                        <div key={index} className="text-sm mb-2 p-2 bg-white rounded">
                          <div className="flex items-center justify-between">
                            <span className="font-medium">{call.toolName}</span>
                            <span className="text-gray-500 text-xs">
                              {formatTimestamp(call.timestamp)}
                            </span>
                          </div>
                          <div className="text-xs text-gray-600 mt-1">
                            ID: {call.id}
                          </div>
                          <details className="mt-1">
                            <summary className="cursor-pointer text-xs text-blue-600">
                              查看参数
                            </summary>
                            <pre className="text-xs bg-gray-100 p-2 rounded mt-1">
                              {JSON.stringify(call.args, null, 2)}
                            </pre>
                          </details>
                        </div>
                      ))
                    )}
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'performance' && state && (
            <div className="p-4">
              <h3 className="text-lg font-semibold mb-4">性能指标</h3>
              <div className="grid grid-cols-2 gap-4">
                <div className="bg-gray-50 p-4 rounded">
                  <h4 className="font-medium text-gray-700 mb-2">执行统计</h4>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between">
                      <span>步骤数:</span>
                      <span className="font-medium">{state.metadata.stepCount}</span>
                    </div>
                    <div className="flex justify-between">
                      <span>总执行时间:</span>
                      <span className="font-medium">
                        {state.metadata.performance.totalTime}ms
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>工具执行时间:</span>
                      <span className="font-medium">
                        {state.metadata.performance.toolExecutionTime}ms
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>LLM调用次数:</span>
                      <span className="font-medium">
                        {state.metadata.performance.llmCalls}
                      </span>
                    </div>
                  </div>
                </div>

                <div className="bg-gray-50 p-4 rounded">
                  <h4 className="font-medium text-gray-700 mb-2">令牌使用</h4>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between">
                      <span>提示令牌:</span>
                      <span className="font-medium">
                        {state.metadata.performance.tokenUsage.prompt}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>完成令牌:</span>
                      <span className="font-medium">
                        {state.metadata.performance.tokenUsage.completion}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>总令牌:</span>
                      <span className="font-medium">
                        {state.metadata.performance.tokenUsage.total}
                      </span>
                    </div>
                  </div>
                </div>

                <div className="bg-gray-50 p-4 rounded">
                  <h4 className="font-medium text-gray-700 mb-2">内存使用</h4>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between">
                      <span>已使用:</span>
                      <span className="font-medium">
                        {formatMemory(state.metadata.performance.memoryUsage.used)}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>总量:</span>
                      <span className="font-medium">
                        {formatMemory(state.metadata.performance.memoryUsage.total)}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>使用率:</span>
                      <span className="font-medium">
                        {state.metadata.performance.memoryUsage.percentage.toFixed(1)}%
                      </span>
                    </div>
                  </div>
                </div>

                <div className="bg-gray-50 p-4 rounded">
                  <h4 className="font-medium text-gray-700 mb-2">错误统计</h4>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between">
                      <span>错误数量:</span>
                      <span className="font-medium text-red-600">
                        {state.metadata.errors.length}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>错误率:</span>
                      <span className="font-medium">
                        {state.metadata.stepCount > 0
                          ? ((state.metadata.errors.length / state.metadata.stepCount) * 100).toFixed(1) + '%'
                          : '0%'
                        }
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="border-t p-4">
          <div className="flex space-x-2">
            <button
              onClick={() => onAction?.('export-state', state)}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
            >
              导出状态
            </button>
            <button
              onClick={() => onAction?.('export-events', events)}
              className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm"
            >
              导出事件
            </button>
            <button
              onClick={() => onAction?.('clear-events', {})}
              className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 text-sm"
            >
              清除事件
            </button>
            <button
              onClick={() => onAction?.('reload', {})}
              className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 text-sm"
            >
              重新加载
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
```

### 6. 创建测试配置和脚本

创建`jest.config.agent.js`:

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/agent'],
  testMatch: [
    '**/__tests__/**/*.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'agent/**/*.ts',
    '!agent/**/*.d.ts',
    '!agent/**/*.test.ts',
    '!agent/**/*.spec.ts'
  ],
  coverageDirectory: 'coverage/agent',
  coverageReporters: ['text', 'lcov', 'html'],
  setupFilesAfterEnv: ['<rootDir>/agent/tests/setup.ts'],
  testTimeout: 30000,
  maxWorkers: 4,
  verbose: true,
  globals: {
    'ts-jest': {
      isolatedModules: true
    }
  }
}
```

创建`agent/tests/setup.ts`:

```typescript
import { jest } from '@jest/globals'

// 全局测试设置
global.console = {
  ...console,
  // 在测试中禁用一些console方法，减少噪音
  log: jest.fn(),
  debug: jest.fn(),
  info: jest.fn(),
  warn: jest.fn(),
  error: console.error, // 保留错误输出
}

// 模拟浏览器环境
global.window = {
  setTimeout,
  clearTimeout,
  setInterval,
  clearInterval,
} as any

global.document = {} as any

// 设置测试超时
jest.setTimeout(30000)

// 全局模拟
jest.mock('@langchain/openai', () => ({
  ChatOpenAI: jest.fn().mockImplementation(() => ({
    invoke: jest.fn(),
    stream: jest.fn()
  }))
}))

// 添加自定义匹配器
expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling
    if (pass) {
      return {
        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,
        pass: true,
      }
    } else {
      return {
        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,
        pass: false,
      }
    }
  },
})

// 清理函数
afterEach(() => {
  jest.clearAllMocks()
  jest.clearAllTimers()
})
```

创建`package.json`测试脚本:

```json
{
  "scripts": {
    "test:agent": "jest --config jest.config.agent.js",
    "test:agent:unit": "jest --config jest.config.agent.js --testPathPattern=unit",
    "test:agent:integration": "jest --config jest.config.agent.js --testPathPattern=integration",
    "test:agent:performance": "jest --config jest.config.agent.js --testPathPattern=performance",
    "test:agent:watch": "jest --config jest.config.agent.js --watch",
    "test:agent:coverage": "jest --config jest.config.agent.js --coverage",
    "test:agent:debug": "node --inspect-brk node_modules/.bin/jest --config jest.config.agent.js --runInBand"
  }
}
```

## 验证清单

- [ ] 测试框架和工具集实现完整
- [ ] 单元测试套件覆盖率达到80%以上
- [ ] 集成测试涵盖主要工作流
- [ ] 性能测试包含基准和压力测试
- [ ] 调试面板功能完整且用户友好
- [ ] 测试配置和脚本正确配置
- [ ] 代码质量检查工具配置完成
- [ ] 测试文档和使用指南完整
- [ ] 持续集成测试流程建立
- [ ] 测试报告生成机制可用

## 测试命令

```bash
# 运行所有Agent测试
npm run test:agent

# 运行单元测试
npm run test:agent:unit

# 运行集成测试
npm run test:agent:integration

# 运行性能测试
npm run test:agent:performance

# 监视模式运行测试
npm run test:agent:watch

# 生成测试覆盖率报告
npm run test:agent:coverage

# 调试模式运行测试
npm run test:agent:debug

# 特定文件测试
npm run test:agent -- agent/tests/unit/supervisor-node.test.ts
```

## 注意事项

- 测试应该模拟真实使用场景，避免过度mock
- 性能测试需要在独立的测试环境中运行
- 调试工具应该提供足够的信息但不过于复杂
- 测试覆盖率应该作为代码质量的重要指标
- 持续集成应该包含自动化测试流程

## 下一步

完成本任务后，第4阶段（LangGraph Agent）的所有核心任务就已完成。系统将具备完整的智能代理功能、流式处理能力、实时响应机制和完善的测试调试工具，为用户提供高质量的TMS NL-Ops演示体验。

## 相关文件

- `/agent/testing/test-framework.ts` - 测试框架核心
- `/agent/tests/unit/` - 单元测试目录
- `/agent/tests/integration/` - 集成测试目录
- `/agent/tests/performance/` - 性能测试目录
- `/agent/debugging/debug-panel.tsx` - 调试面板组件
- `/jest.config.agent.js` - Jest配置文件
- `/agent/tests/setup.ts` - 测试环境设置