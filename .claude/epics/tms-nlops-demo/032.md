---
title: 排车计划组件 (DispatchPlan) 实现
epic: tms-nlops-demo
task_id: 032
type: task
status: todo
priority: high
tags: ["ui", "component", "react", "dispatch", "planning"]
assignee: ""
created: 2025-09-20T04:20:45Z
updated: 2025-09-20T04:20:45Z
enabled: true
parallel: false
depends_on: ["030", "027"]
effort: 5
description: 实现排车计划组件，支持可视化排车、优化算法集成和生成式UI功能
---

## 任务描述

实现一个智能排车计划组件，支持可视化排车操作、自动优化算法集成，并提供生成式UI功能，帮助调度员高效制定车辆配送计划。

## 详细需求

### 1. 可视化排车界面
- **时间轴视图**: 按时间展示车辆调度计划
- **地图视图**: 在地图上显示车辆路线和配送点
- **甘特图**: 展示车辆和司机的工作时间安排
- **拖拽操作**: 支持拖拽调整订单和车辆分配

### 2. 排车功能
- **手动排车**: 支持人工拖拽分配订单
- **自动排车**: 集成优化算法自动生成排车计划
- **批量排车**: 支持批量处理订单分配
- **冲突检测**: 自动检测时间冲突和资源冲突

### 3. 优化算法集成
- **路径优化**: 集成TSP算法优化配送路线
- **装载优化**: 考虑车辆载重和容积限制
- **时间窗优化**: 满足客户时间窗要求
- **成本优化**: 最小化运输成本

### 4. 生成式UI功能
- **智能建议**: AI推荐最佳排车方案
- **异常处理**: 自动识别和处理排车异常
- **预测分析**: 预测配送时间和可能延误
- **自然语言指令**: 支持自然语言排车指令

## 技术实现

### 组件结构
```typescript
interface Vehicle {
  id: string;
  licensePlate: string;
  type: VehicleType;
  capacity: {
    weight: number;
    volume: number;
  };
  driver: Driver;
  currentLocation?: Location;
  status: VehicleStatus;
  schedule: DispatchSchedule[];
}

interface DispatchSchedule {
  id: string;
  vehicleId: string;
  orderId: string;
  sequence: number;
  estimatedArrival: Date;
  estimatedDeparture: Date;
  actualArrival?: Date;
  actualDeparture?: Date;
  status: ScheduleStatus;
  distance: number;
  duration: number;
}

interface DispatchPlanProps {
  vehicles: Vehicle[];
  orders: Order[];
  schedules: DispatchSchedule[];
  loading?: boolean;
  onScheduleUpdate?: (schedule: DispatchSchedule) => void;
  onOptimize?: (options: OptimizationOptions) => void;
  onVehicleAssign?: (vehicleId: string, orderId: string) => void;
  onConflictResolve?: (conflict: Conflict) => void;
}
```

### 主要功能模块
- **TimelineView**: 时间轴视图组件
- **MapView**: 地图视图组件
- **GanttChart**: 甘特图组件
- **VehiclePanel**: 车辆信息面板
- **OrderPool**: 订单池组件
- **OptimizationEngine**: 优化算法引擎
- **ConflictDetector**: 冲突检测组件

### 优化算法接口
```typescript
interface OptimizationEngine {
  optimizeRoutes(vehicles: Vehicle[], orders: Order[]): Promise<OptimizationResult>;
  optimizeLoading(vehicle: Vehicle, orders: Order[]): Promise<LoadingPlan>;
  optimizeTimeWindows(schedules: DispatchSchedule[]): Promise<TimeWindowPlan>;
  calculateCost(schedules: DispatchSchedule[]): Promise<number>;
}

interface OptimizationOptions {
  objective: 'cost' | 'time' | 'distance' | 'balanced';
  constraints: {
    timeWindows: boolean;
    capacity: boolean;
    driverHours: boolean;
    vehicleAvailability: boolean;
  };
  preferences: {
    prioritizeUrgent: boolean;
    minimizeDetours: boolean;
    balanceWorkload: boolean;
  };
}
```

### 生成式UI集成
```typescript
interface SmartDispatcher {
  generateRecommendations(vehicles: Vehicle[], orders: Order[]): Promise<DispatchRecommendation[]>;
  processNaturalLanguage(command: string): Promise<DispatchAction>;
  predictDelays(schedules: DispatchSchedule[]): Promise<DelayPrediction[]>;
  resolveConflicts(conflicts: Conflict[]): Promise<ConflictResolution[]>;
}
```

## 交付成果

1. **DispatchPlan组件**: 完整的排车计划组件实现
2. **子组件实现**: TimelineView、MapView、GanttChart等子组件
3. **优化算法**: 路径优化、装载优化等算法实现
4. **类型定义**: 完整的TypeScript类型定义
5. **样式文件**: 组件样式和响应式设计
6. **单元测试**: 组件功能和算法测试用例

## 验收标准

- [ ] 可视化界面正确展示排车计划
- [ ] 拖拽操作功能正常工作
- [ ] 自动排车算法生成合理方案
- [ ] 冲突检测准确识别问题
- [ ] 优化算法满足业务约束条件
- [ ] 地图视图显示正确路线和配送点
- [ ] 甘特图准确反映时间安排
- [ ] 生成式UI推荐准确率>75%
- [ ] 自然语言指令正确解析和执行
- [ ] 性能测试：100+车辆和500+订单场景流畅运行
- [ ] 响应式设计在不同设备上正常显示
- [ ] 单元测试覆盖率达到85%以上
- [ ] 集成测试与订单管理、车辆跟踪组件正常协作

## 相关文件

- `/src/components/ui/DispatchPlan/` - 排车计划组件目录
- `/src/components/ui/DispatchPlan/index.tsx` - 主组件文件
- `/src/components/ui/DispatchPlan/TimelineView.tsx` - 时间轴视图
- `/src/components/ui/DispatchPlan/MapView.tsx` - 地图视图
- `/src/components/ui/DispatchPlan/GanttChart.tsx` - 甘特图组件
- `/src/algorithms/dispatch/` - 排车算法目录
- `/src/types/dispatch.ts` - 排车相关类型定义
- `/src/hooks/useDispatchPlan.ts` - 排车计划自定义Hook

## 注意事项

1. 算法性能是关键，需要处理大规模优化问题
2. 可视化界面要直观易懂，降低学习成本
3. 拖拽操作要流畅，提供实时反馈
4. 优化算法要考虑实际业务约束
5. 生成式UI功能要与调度员工作流程紧密集成
6. 错误处理要完善，提供清晰的异常提示
7. 代码要模块化，便于算法升级和维护