---
title: "TMS NL-Ops演示系统任务014: API数据验证和错误处理中间件"
epic: "tms-nlops-demo"
task: "014"
phase: "2"
status: completed
priority: "high"
estimated_hours: 2
parallel: true
depends_on: ["001", "002", "003", "004", "005", "006", "007"]
tags: ["middleware", "validation", "error-handling", "backend", "typescript"]
created: "2025-09-20T04:20:45Z"
updated: "2025-09-20T04:20:45Z"
---

## 概述

实现API数据验证和错误处理中间件，为整个TMS NL-Ops演示系统提供统一的数据验证、错误处理和响应格式化功能。构建健壮的API基础设施。

## 目标

- 实现统一的数据验证中间件
- 创建全局错误处理机制
- 标准化API响应格式
- 实现请求日志记录
- 提供安全防护功能

## 技术栈

- **框架**: Next.js 15+ Middleware
- **语言**: TypeScript
- **验证**: Zod schema validation
- **日志**: Winston或自定义日志系统
- **安全**: Helmet、CORS、Rate limiting
- **监控**: 错误监控和性能跟踪

## 实施步骤

### 1. 创建中间件配置

创建`src/middleware.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { validateRequest } from '@/lib/validation'
import { rateLimit } from '@/lib/rateLimit'
import { logger } from '@/lib/logger'
import { securityHeaders } from '@/lib/security'

export async function middleware(request: NextRequest) {
  try {
    // 记录请求日志
    await logRequest(request)

    // 安全头设置
    const response = NextResponse.next()
    securityHeaders.forEach(({ name, value }) => {
      response.headers.set(name, value)
    })

    // 速率限制
    const rateLimitResult = await rateLimit(request)
    if (!rateLimitResult.allowed) {
      return NextResponse.json(
        {
          success: false,
          error: '请求过于频繁',
          code: 'RATE_LIMIT_EXCEEDED',
          details: {
            retryAfter: rateLimitResult.retryAfter
          }
        },
        { status: 429 }
      )
    }

    // API路由验证
    if (request.nextUrl.pathname.startsWith('/api/')) {
      // 验证请求格式
      const validationResult = await validateRequest(request)
      if (!validationResult.valid) {
        return NextResponse.json(
          {
            success: false,
            error: '请求验证失败',
            code: 'INVALID_REQUEST',
            details: validationResult.errors
          },
          { status: 400 }
        )
      }

      // CORS处理
      if (request.method === 'OPTIONS') {
        return new NextResponse(null, {
          status: 200,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
            'Access-Control-Max-Age': '86400'
          }
        })
      }
    }

    return response
  } catch (error) {
    logger.error('中间件错误:', error)
    return NextResponse.json(
      {
        success: false,
        error: '服务器内部错误',
        code: 'INTERNAL_SERVER_ERROR'
      },
      { status: 500 }
    )
  }
}

export const config = {
  matcher: [
    '/api/:path*',
    '/((?!_next/static|_next/image|favicon.ico).*)'
  ]
}

async function logRequest(request: NextRequest) {
  const startTime = Date.now()

  // 在响应完成后记录请求信息
  request.headers.set('x-request-start', startTime.toString())

  logger.info('API请求', {
    method: request.method,
    url: request.url,
    userAgent: request.headers.get('user-agent'),
    ip: request.headers.get('x-forwarded-for') || 'unknown',
    timestamp: new Date().toISOString()
  })
}
```

### 2. 创建错误处理工具

创建`src/lib/errorHandler.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { logger } from '@/lib/logger'
import { ZodError } from 'zod'
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library'

export interface APIError {
  code: string
  message: string
  details?: any
  stack?: string
}

export class AppError extends Error {
  public readonly code: string
  public readonly statusCode: number
  public readonly isOperational: boolean

  constructor(code: string, message: string, statusCode: number = 500, isOperational: boolean = true) {
    super(message)
    this.code = code
    this.statusCode = statusCode
    this.isOperational = isOperational
    Error.captureStackTrace(this, this.constructor)
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: any) {
    super('VALIDATION_ERROR', message, 400, true)
    this.details = details
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super('NOT_FOUND', `${resource} 不存在`, 404, true)
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = '未授权访问') {
    super('UNAUTHORIZED', message, 401, true)
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = '权限不足') {
    super('FORBIDDEN', message, 403, true)
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super('CONFLICT', message, 409, true)
  }
}

export function handleAPIError(error: any, request?: NextRequest): NextResponse {
  logger.error('API错误:', {
    error: error.message,
    stack: error.stack,
    url: request?.url,
    method: request?.method,
    timestamp: new Date().toISOString()
  })

  // 处理已知错误类型
  if (error instanceof AppError) {
    return NextResponse.json(
      {
        success: false,
        error: error.message,
        code: error.code,
        details: error.details,
        timestamp: new Date().toISOString()
      },
      { status: error.statusCode }
    )
  }

  // 处理Zod验证错误
  if (error instanceof ZodError) {
    return NextResponse.json(
      {
        success: false,
        error: '数据验证失败',
        code: 'VALIDATION_ERROR',
        details: error.errors,
        timestamp: new Date().toISOString()
      },
      { status: 400 }
    )
  }

  // 处理Prisma数据库错误
  if (error instanceof PrismaClientKnownRequestError) {
    const prismaError = handlePrismaError(error)
    return NextResponse.json(
      {
        success: false,
        error: prismaError.message,
        code: prismaError.code,
        timestamp: new Date().toISOString()
      },
      { status: prismaError.statusCode }
    )
  }

  // 处理未知错误
  return NextResponse.json(
    {
      success: false,
      error: '服务器内部错误',
      code: 'INTERNAL_SERVER_ERROR',
      timestamp: new Date().toISOString()
    },
    { status: 500 }
  )
}

function handlePrismaError(error: PrismaClientKnownRequestError) {
  switch (error.code) {
    case 'P2002':
      return {
        code: 'UNIQUE_CONSTRAINT_VIOLATION',
        message: '数据已存在',
        statusCode: 409
      }
    case 'P2003':
      return {
        code: 'FOREIGN_KEY_CONSTRAINT_VIOLATION',
        message: '外键约束违反',
        statusCode: 400
      }
    case 'P2025':
      return {
        code: 'NOT_FOUND',
        message: '记录不存在',
        statusCode: 404
      }
    case 'P2014':
      return {
        code: 'INVALID_RELATION',
        message: '关系无效',
        statusCode: 400
      }
    case 'P2001':
      return {
        code: 'CONSTRAINT_VIOLATION',
        message: '约束违反',
        statusCode: 400
      }
    default:
      return {
        code: 'DATABASE_ERROR',
        message: '数据库错误',
        statusCode: 500
      }
  }
}

export function createSuccessResponse<T>(
  data: T,
  message?: string,
  statusCode: number = 200
): NextResponse {
  return NextResponse.json(
    {
      success: true,
      data,
      message,
      timestamp: new Date().toISOString()
    },
    { status: statusCode }
  )
}

export function createErrorResponse(
  error: string,
  code: string,
  statusCode: number = 400,
  details?: any
): NextResponse {
  return NextResponse.json(
    {
      success: false,
      error,
      code,
      details,
      timestamp: new Date().toISOString()
    },
    { status: statusCode }
  )
}

export function createPaginatedResponse<T>(
  data: T[],
  pagination: {
    page: number
    limit: number
    total: number
    pages: number
  },
  message?: string
): NextResponse {
  return NextResponse.json(
    {
      success: true,
      data,
      pagination,
      message,
      timestamp: new Date().toISOString()
    }
  )
}
```

### 3. 创建数据验证工具

创建`src/lib/validation.ts`:

```typescript
import { NextRequest } from 'next/server'
import { z } from 'zod'
import { ValidationError } from './errorHandler'

export interface ValidationResult {
  valid: boolean
  errors?: any[]
}

export async function validateRequest(request: NextRequest): Promise<ValidationResult> {
  try {
    // 验证请求头
    const headerValidation = validateHeaders(request)
    if (!headerValidation.valid) {
      return headerValidation
    }

    // 验证请求方法
    const methodValidation = validateMethod(request)
    if (!methodValidation.valid) {
      return methodValidation
    }

    // 如果有请求体，验证Content-Type
    if (request.method !== 'GET' && request.method !== 'HEAD') {
      const contentTypeValidation = validateContentType(request)
      if (!contentTypeValidation.valid) {
        return contentTypeValidation
      }
    }

    return { valid: true }
  } catch (error) {
    return {
      valid: false,
      errors: [{ message: '请求验证失败', details: error.message }]
    }
  }
}

function validateHeaders(request: NextRequest): ValidationResult {
  const requiredHeaders = []
  const errors: any[] = []

  // 检查必需的请求头
  for (const header of requiredHeaders) {
    if (!request.headers.get(header)) {
      errors.push({
        field: 'headers',
        message: `缺少必需的请求头: ${header}`
      })
    }
  }

  // 验证User-Agent
  const userAgent = request.headers.get('user-agent')
  if (!userAgent || userAgent.length < 10) {
    errors.push({
      field: 'user-agent',
      message: '无效的User-Agent'
    })
  }

  // 验证Content-Length (对于有请求体的请求)
  const contentLength = request.headers.get('content-length')
  if (request.method !== 'GET' && request.method !== 'HEAD') {
    const length = parseInt(contentLength || '0')
    if (length > 10 * 1024 * 1024) { // 10MB限制
      errors.push({
        field: 'content-length',
        message: '请求体过大，最大支持10MB'
      })
    }
  }

  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : undefined
  }
}

function validateMethod(request: NextRequest): ValidationResult {
  const allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']

  if (!allowedMethods.includes(request.method)) {
    return {
      valid: false,
      errors: [{
        field: 'method',
        message: `不支持的HTTP方法: ${request.method}`
      }]
    }
  }

  return { valid: true }
}

function validateContentType(request: NextRequest): ValidationResult {
  const contentType = request.headers.get('content-type')

  if (!contentType) {
    return {
      valid: false,
      errors: [{
        field: 'content-type',
        message: '缺少Content-Type头'
      }]
    }
  }

  const allowedContentTypes = [
    'application/json',
    'application/x-www-form-urlencoded',
    'multipart/form-data'
  ]

  const isAllowed = allowedContentTypes.some(type =>
    contentType.toLowerCase().includes(type.toLowerCase())
  )

  if (!isAllowed) {
    return {
      valid: false,
      errors: [{
        field: 'content-type',
        message: `不支持的Content-Type: ${contentType}`
      }]
    }
  }

  return { valid: true }
}

export async function validateBody<T>(
  request: NextRequest,
  schema: z.ZodSchema<T>
): Promise<T> {
  try {
    const body = await parseRequestBody(request)
    const validatedData = schema.parse(body)
    return validatedData
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ValidationError('数据验证失败', error.errors)
    }
    throw new ValidationError('请求体解析失败')
  }
}

export async function validateQuery<T>(
  request: NextRequest,
  schema: z.ZodSchema<T>
): Promise<T> {
  try {
    const searchParams = request.nextUrl.searchParams
    const query: any = {}

    // 将URL参数转换为对象
    for (const [key, value] of searchParams.entries()) {
      // 处理数组参数
      if (query[key]) {
        if (Array.isArray(query[key])) {
          query[key].push(value)
        } else {
          query[key] = [query[key], value]
        }
      } else {
        query[key] = value
      }
    }

    const validatedQuery = schema.parse(query)
    return validatedQuery
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ValidationError('查询参数验证失败', error.errors)
    }
    throw new ValidationError('查询参数解析失败')
  }
}

export async function validateParams<T>(
  request: NextRequest,
  schema: z.ZodSchema<T>
): Promise<T> {
  try {
    const pathname = request.nextUrl.pathname
    const segments = pathname.split('/')

    // 获取动态参数
    const params: any = {}

    // 简化版参数提取，实际应该根据路由配置提取
    if (segments.length >= 4) {
      params.id = segments[3] // /api/resource/:id
    }

    const validatedParams = schema.parse(params)
    return validatedParams
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ValidationError('路径参数验证失败', error.errors)
    }
    throw new ValidationError('路径参数解析失败')
  }
}

async function parseRequestBody(request: NextRequest): Promise<any> {
  const contentType = request.headers.get('content-type') || ''

  if (contentType.includes('application/json')) {
    return await request.json()
  }

  if (contentType.includes('application/x-www-form-urlencoded')) {
    const formData = await request.formData()
    const result: any = {}
    for (const [key, value] of formData.entries()) {
      result[key] = value
    }
    return result
  }

  if (contentType.includes('multipart/form-data')) {
    const formData = await request.formData()
    const result: any = {}
    for (const [key, value] of formData.entries()) {
      result[key] = value
    }
    return result
  }

  throw new ValidationError(`不支持的Content-Type: ${contentType}`)
}

// 创建通用验证器
export function createValidator<T>(schema: z.ZodSchema<T>) {
  return {
    body: (request: NextRequest) => validateBody(request, schema),
    query: (request: NextRequest) => validateQuery(request, schema),
    params: (request: NextRequest) => validateParams(request, schema)
  }
}
```

### 4. 创建日志系统

创建`src/lib/logger.ts`:

```typescript
import winston from 'winston'

// 定义日志级别
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
}

// 定义日志颜色
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'blue',
}

// 告诉winston使用这些颜色
winston.addColors(colors)

// 定义要打印的日志格式
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.colorize({ all: true }),
  winston.format.printf(
    (info) => `${info.timestamp} ${info.level}: ${info.message}`,
  ),
)

// 指定日志文件
const transports = [
  // 控制台输出
  new winston.transports.Console(),
  // 错误日志文件
  new winston.transports.File({
    filename: 'logs/error.log',
    level: 'error',
  }),
  // 所有日志文件
  new winston.transports.File({ filename: 'logs/all.log' }),
]

// 创建logger
export const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'development' ? 'debug' : 'warn',
  levels,
  format,
  transports,
})

// 创建API请求专用logger
export const apiLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/api.log' })
  ]
})

// 创建性能监控logger
export const performanceLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/performance.log' })
  ]
})

// 扩展logger接口
declare global {
  interface Console {
    logRequest: (data: any) => void
    logPerformance: (data: any) => void
    logError: (error: Error, context?: any) => void
  }
}

// 添加自定义方法
console.logRequest = (data: any) => {
  apiLogger.info('API Request', data)
}

console.logPerformance = (data: any) => {
  performanceLogger.info('Performance', data)
}

console.logError = (error: Error, context?: any) => {
  logger.error('Application Error', {
    error: error.message,
    stack: error.stack,
    context,
    timestamp: new Date().toISOString()
  })
}
```

### 5. 创建安全工具

创建`src/lib/security.ts`:

```typescript
// 安全头配置
export const securityHeaders = [
  {
    name: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    name: 'X-Frame-Options',
    value: 'DENY'
  },
  {
    name: 'X-XSS-Protection',
    value: '1; mode=block'
  },
  {
    name: 'Referrer-Policy',
    value: 'strict-origin-when-cross-origin'
  },
  {
    name: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=()'
  },
  {
    name: 'Content-Security-Policy',
    value: "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"
  }
]

// 速率限制配置
interface RateLimitConfig {
  windowMs: number // 时间窗口（毫秒）
  max: number // 最大请求数
  skipSuccessfulRequests?: boolean
  skipFailedRequests?: boolean
  keyGenerator?: (req: NextRequest) => string
}

const defaultRateLimitConfig: RateLimitConfig = {
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 限制每个IP 100个请求
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  keyGenerator: (req: NextRequest) => {
    return req.headers.get('x-forwarded-for') ||
           req.headers.get('x-real-ip') ||
           'unknown'
  }
}

// 简单的内存存储（生产环境应使用Redis等）
const rateLimitStore = new Map<string, { count: number; resetTime: number }>()

export async function rateLimit(
  request: NextRequest,
  config: Partial<RateLimitConfig> = {}
): Promise<{ allowed: boolean; retryAfter?: number }> {
  const finalConfig = { ...defaultRateLimitConfig, ...config }
  const key = finalConfig.keyGenerator!(request)
  const now = Date.now()

  // 清理过期的记录
  if (rateLimitStore.size > 10000) {
    for (const [k, v] of rateLimitStore.entries()) {
      if (v.resetTime < now) {
        rateLimitStore.delete(k)
      }
    }
  }

  let record = rateLimitStore.get(key)

  if (!record || record.resetTime < now) {
    // 创建新记录
    record = {
      count: 1,
      resetTime: now + finalConfig.windowMs
    }
    rateLimitStore.set(key, record)
    return { allowed: true }
  }

  record.count++

  if (record.count > finalConfig.max) {
    const retryAfter = Math.ceil((record.resetTime - now) / 1000)
    return { allowed: false, retryAfter }
  }

  return { allowed: true }
}

// 输入验证和清理
export function sanitizeInput(input: string): string {
  if (typeof input !== 'string') return input

  // 移除潜在的XSS攻击
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
}

// SQL注入防护
export function sanitizeForSQL(input: string): string {
  if (typeof input !== 'string') return input

  // 移除潜在的SQL注入字符
  return input
    .replace(/['"]/g, '')
    .replace(/;/g, '')
    .replace(/--/g, '')
    .replace(/\/\*/g, '')
    .replace(/\*\//g, '')
}

// 路径遍历攻击防护
export function sanitizeFilePath(path: string): string {
  if (typeof path !== 'string') return path

  // 移除路径遍历字符
  return path
    .replace(/\.\./g, '')
    .replace(/^\//, '')
    .replace(/\//g, '_')
}

// JWT验证
export function validateJWT(token: string): any {
  try {
    // 这里应该使用实际的JWT验证库
    // 简化版本，仅作示例
    const parts = token.split('.')
    if (parts.length !== 3) {
      throw new Error('Invalid token format')
    }

    const payload = JSON.parse(atob(parts[1]))

    // 检查过期时间
    if (payload.exp && payload.exp < Date.now() / 1000) {
      throw new Error('Token expired')
    }

    return payload
  } catch (error) {
    throw new Error('Invalid token')
  }
}

// 权限检查
export function checkPermission(
  userPermissions: string[],
  requiredPermissions: string[]
): boolean {
  return requiredPermissions.every(permission =>
    userPermissions.includes(permission)
  )
}

// 角色检查
export function checkRole(
  userRoles: string[],
  requiredRoles: string[]
): boolean {
  return requiredRoles.some(role => userRoles.includes(role))
}

// API密钥验证
export function validateAPIKey(apiKey: string): boolean {
  // 这里应该实现实际的API密钥验证逻辑
  // 简化版本，仅作示例
  const validKeys = process.env.API_KEYS?.split(',') || []
  return validKeys.includes(apiKey)
}

// 请求签名验证
export function validateSignature(
  request: NextRequest,
  secret: string
): boolean {
  try {
    const signature = request.headers.get('x-signature')
    const timestamp = request.headers.get('x-timestamp')

    if (!signature || !timestamp) {
      return false
    }

    // 检查时间戳是否在有效范围内（5分钟）
    const now = Date.now()
    const requestTime = parseInt(timestamp)
    if (Math.abs(now - requestTime) > 5 * 60 * 1000) {
      return false
    }

    // 这里应该实现实际的签名验证逻辑
    // 简化版本，仅作示例
    return true
  } catch (error) {
    return false
  }
}
```

### 6. 创建性能监控

创建`src/lib/performance.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { performanceLogger } from './logger'

interface PerformanceMetrics {
  startTime: number
  endTime: number
  duration: number
  memoryUsage: NodeJS.MemoryUsage
  requestSize: number
  responseSize: number
}

export class PerformanceMonitor {
  private static activeRequests = new Map<string, PerformanceMetrics>()

  static startRequest(requestId: string): void {
    this.activeRequests.set(requestId, {
      startTime: performance.now(),
      endTime: 0,
      duration: 0,
      memoryUsage: process.memoryUsage(),
      requestSize: 0,
      responseSize: 0
    })
  }

  static endRequest(requestId: string, responseSize: number = 0): void {
    const metrics = this.activeRequests.get(requestId)
    if (!metrics) return

    metrics.endTime = performance.now()
    metrics.duration = metrics.endTime - metrics.startTime
    metrics.responseSize = responseSize

    // 记录性能数据
    performanceLogger.info('Request Performance', {
      requestId,
      duration: metrics.duration,
      memoryUsage: {
        heapUsed: metrics.memoryUsage.heapUsed,
        heapTotal: metrics.memoryUsage.heapTotal,
        external: metrics.memoryUsage.external
      },
      requestSize: metrics.requestSize,
      responseSize: metrics.responseSize
    })

    this.activeRequests.delete(requestId)

    // 检查性能阈值
    this.checkPerformanceThresholds(metrics)
  }

  private static checkPerformanceThresholds(metrics: PerformanceMetrics): void {
    const thresholds = {
      slowRequest: 1000, // 1秒
      verySlowRequest: 5000, // 5秒
      memoryHeavy: 100 * 1024 * 1024, // 100MB
      largeResponse: 10 * 1024 * 1024, // 10MB
    }

    if (metrics.duration > thresholds.verySlowRequest) {
      performanceLogger.warn('Very Slow Request', {
        duration: metrics.duration,
        threshold: thresholds.verySlowRequest
      })
    } else if (metrics.duration > thresholds.slowRequest) {
      performanceLogger.warn('Slow Request', {
        duration: metrics.duration,
        threshold: thresholds.slowRequest
      })
    }

    if (metrics.memoryUsage.heapUsed > thresholds.memoryHeavy) {
      performanceLogger.warn('Memory Heavy Request', {
        heapUsed: metrics.memoryUsage.heapUsed,
        threshold: thresholds.memoryHeavy
      })
    }

    if (metrics.responseSize > thresholds.largeResponse) {
      performanceLogger.warn('Large Response', {
        responseSize: metrics.responseSize,
        threshold: thresholds.largeResponse
      })
    }
  }
}

// 性能监控中间件
export function withPerformanceMonitoring(
  handler: (request: NextRequest) => Promise<NextResponse>
) {
  return async (request: NextRequest): Promise<NextResponse> => {
    const requestId = generateRequestId()
    request.headers.set('x-request-id', requestId)

    PerformanceMonitor.startRequest(requestId)

    try {
      const response = await handler(request)

      // 计算响应大小
      const responseSize = await calculateResponseSize(response)
      PerformanceMonitor.endRequest(requestId, responseSize)

      // 添加性能头
      response.headers.set('x-response-time',
        PerformanceMonitor.activeRequests.get(requestId)?.duration?.toString() || '0'
      )
      response.headers.set('x-request-id', requestId)

      return response
    } catch (error) {
      PerformanceMonitor.endRequest(requestId, 0)
      throw error
    }
  }
}

function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

async function calculateResponseSize(response: NextResponse): Promise<number> {
  try {
    const body = await response.json()
    return JSON.stringify(body).length
  } catch {
    return 0
  }
}

// 数据库查询性能监控
export function monitorDatabaseQuery<T>(
  operation: string,
  query: () => Promise<T>
): Promise<T> {
  const startTime = performance.now()

  return query()
    .then(result => {
      const duration = performance.now() - startTime
      performanceLogger.info('Database Query', {
        operation,
        duration,
        success: true
      })
      return result
    })
    .catch(error => {
      const duration = performance.now() - startTime
      performanceLogger.error('Database Query Failed', {
        operation,
        duration,
        error: error.message
      })
      throw error
    })
}

// 内存使用监控
export function startMemoryMonitoring(): void {
  setInterval(() => {
    const memoryUsage = process.memoryUsage()

    performanceLogger.info('Memory Usage', {
      rss: memoryUsage.rss,
      heapTotal: memoryUsage.heapTotal,
      heapUsed: memoryUsage.heapUsed,
      external: memoryUsage.external,
      arrayBuffers: memoryUsage.arrayBuffers
    })

    // 内存使用率告警
    const memoryUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100
    if (memoryUsagePercent > 90) {
      performanceLogger.warn('High Memory Usage', {
        memoryUsagePercent: Math.round(memoryUsagePercent)
      })
    }
  }, 60000) // 每分钟检查一次
}
```

### 7. 创建响应拦截器

创建`src/lib/responseInterceptor.ts`:

```typescript
import { NextResponse } from 'next/server'
import { logger } from './logger'

export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: string
  code?: string
  details?: any
  message?: string
  timestamp: string
  pagination?: {
    page: number
    limit: number
    total: number
    pages: number
  }
}

export class ResponseInterceptor {
  static wrapResponse<T>(
    response: NextResponse,
    data: T,
    statusCode: number = 200,
    message?: string
  ): NextResponse {
    const apiResponse: ApiResponse<T> = {
      success: true,
      data,
      message,
      timestamp: new Date().toISOString()
    }

    const wrappedResponse = NextResponse.json(apiResponse, { status: statusCode })

    // 复制原始响应头
    response.headers.forEach((value, key) => {
      wrappedResponse.headers.set(key, value)
    })

    return wrappedResponse
  }

  static wrapError(
    response: NextResponse,
    error: string,
    statusCode: number = 500,
    code?: string,
    details?: any
  ): NextResponse {
    const apiResponse: ApiResponse = {
      success: false,
      error,
      code,
      details,
      timestamp: new Date().toISOString()
    }

    const wrappedResponse = NextResponse.json(apiResponse, { status: statusCode })

    // 复制原始响应头
    response.headers.forEach((value, key) => {
      wrappedResponse.headers.set(key, value)
    })

    // 记录错误日志
    logger.error('API Error Response', {
      error,
      code,
      details,
      statusCode,
      timestamp: new Date().toISOString()
    })

    return wrappedResponse
  }

  static wrapPaginated<T>(
    response: NextResponse,
    data: T[],
    pagination: {
      page: number
      limit: number
      total: number
      pages: number
    },
    statusCode: number = 200,
    message?: string
  ): NextResponse {
    const apiResponse: ApiResponse<T[]> = {
      success: true,
      data,
      pagination,
      message,
      timestamp: new Date().toISOString()
    }

    const wrappedResponse = NextResponse.json(apiResponse, { status: statusCode })

    // 复制原始响应头
    response.headers.forEach((value, key) => {
      wrappedResponse.headers.set(key, value)
    })

    return wrappedResponse
  }
}

// 创建响应装饰器
export function withResponseHandling(
  handler: (request: Request) => Promise<NextResponse>
) {
  return async (request: Request): Promise<NextResponse> => {
    try {
      const response = await handler(request)
      return response
    } catch (error) {
      logger.error('Unhandled Error in Response Handler', error)
      return ResponseInterceptor.wrapError(
        new NextResponse(),
        '服务器内部错误',
        500,
        'INTERNAL_SERVER_ERROR',
        process.env.NODE_ENV === 'development' ? error.stack : undefined
      )
    }
  }
}
```

## 验证清单

- [ ] 中间件配置正确
- [ ] 错误处理机制完善
- [ ] 数据验证功能正常
- [ ] 日志记录功能正常
- [ ] 安全防护功能有效
- [ ] 性能监控功能正常
- [ ] 响应格式化功能正常
- [ ] 速率限制功能正常
- [ ] 输入清理功能正常
- [ ] 权限检查功能正常

## 测试命令

```bash
# 运行中间件测试
npm run test:middleware

# 运行验证测试
npm run test:validation

# 运行错误处理测试
npm run test:error-handling

# 检查日志文件
ls -la logs/
```

## 注意事项

- 确保所有API路由使用统一的错误处理
- 速率限制应该根据不同端点调整
- 日志记录不应该包含敏感信息
- 性能监控应该考虑生产环境开销
- 安全头配置需要根据实际需求调整
- 输入验证应该覆盖所有可能的攻击向量
- 错误消息应该对用户友好，对开发人员详细
- 响应格式应该保持一致性
- 中间件顺序应该正确（先安全，再验证，再业务）