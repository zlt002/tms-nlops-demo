---
title: "TMS NL-Ops演示系统任务027: LangGraph工作流定义和编译"
epic: "tms-nlops-demo"
task: "027"
phase: "4"
status: "pending"
priority: "high"
estimated_hours: 6
parallel: false
depends_on: ["026"]
tags: ["langgraph", "workflow", "compilation", "state-management"]
created: "2025-09-20T04:20:45Z"
updated: "2025-09-20T04:20:45Z"
---

## 概述

为TMS NL-Ops演示系统实现完整的LangGraph工作流定义、节点连接、条件路由和编译配置，建立智能代理的执行框架和状态流转机制。

## 目标

- 定义完整的LangGraph工作流结构
- 实现节点间的状态传递和路由逻辑
- 配置工作流编译选项和执行参数
- 建立错误恢复和重试机制
- 提供工作流监控和调试接口

## 技术栈

- **核心框架**: LangGraph.js v1.0+
- **状态管理**: StateGraph + 自定义状态注解
- **节点类型**: Agent节点、工具节点、条件节点
- **编译器**: LangGraph编译器
- **调试工具**: LangGraph调试器

## 实施步骤

### 1. 创建状态注解和类型定义

更新`agent/types/state-annotations.ts`:

```typescript
import { Annotation } from "@langchain/langgraph"
import { AgentState } from "./state"
import { BaseMessage } from "@langchain/core/messages"

// 扩展状态注解
export const AgentStateAnnotation = Annotation.Root({
  // 消息列表
  messages: Annotation<BaseMessage[]>({
    reducer: (x, y) => x.concat(y),
    default: () => [],
  }),

  // 上下文信息
  context: Annotation({
    userRole: Annotation<string>({
      default: () => 'customer',
    }),
    currentTask: Annotation<string>({
      default: () => '',
    }),
    taskHistory: Annotation<string[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    intent: Annotation<string>({
      default: () => '',
    }),
    entities: Annotation<Record<string, any>>({
      reducer: (x, y) => ({ ...x, ...y }),
      default: () => ({}),
    }),
    session: Annotation({
      id: Annotation<string>({
        default: () => `session_${Date.now()}_${Math.random()}`,
      }),
      startTime: Annotation<Date>({
        default: () => new Date(),
      }),
      lastActivity: Annotation<Date>({
        default: () => new Date(),
      }),
      metadata: Annotation<Record<string, any>>({
        reducer: (x, y) => ({ ...x, ...y }),
        default: () => ({}),
      }),
    }),
  }),

  // 数据存储
  data: Annotation({
    orders: Annotation<any[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    vehicles: Annotation<any[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    dispatch: Annotation<any>({
      default: () => null,
    }),
    tracking: Annotation<any[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    pod: Annotation<any>({
      default: () => null,
    }),
    customers: Annotation<any[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    results: Annotation<Record<string, any>>({
      reducer: (x, y) => ({ ...x, ...y }),
      default: () => ({}),
    }),
    cache: Annotation<Record<string, any>>({
      reducer: (x, y) => ({ ...x, ...y }),
      default: () => ({}),
    }),
  }),

  // UI状态
  ui: Annotation({
    component: Annotation<string>({
      default: () => '',
    }),
    props: Annotation<Record<string, any>>({
      reducer: (x, y) => ({ ...x, ...y }),
      default: () => ({}),
    }),
    layout: Annotation<string>({
      default: () => 'vertical',
    }),
    actions: Annotation<any[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    loading: Annotation<boolean>({
      default: () => false,
    }),
    error: Annotation<string>({
      default: () => '',
    }),
    timestamp: Annotation<Date>({
      default: () => new Date(),
    }),
  }),

  // 元数据
  metadata: Annotation({
    startTime: Annotation<Date>({
      default: () => new Date(),
    }),
    stepCount: Annotation<number>({
      reducer: (x, y) => x + y,
      default: () => 0,
    }),
    toolCalls: Annotation<any[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    errors: Annotation<any[]>({
      reducer: (x, y) => [...x, ...y],
      default: () => [],
    }),
    performance: Annotation({
      totalTime: Annotation<number>({
        reducer: (x, y) => x + y,
        default: () => 0,
      }),
      toolExecutionTime: Annotation<number>({
        reducer: (x, y) => x + y,
        default: () => 0,
      }),
      llmCalls: Annotation<number>({
        reducer: (x, y) => x + y,
        default: () => 0,
      }),
      tokenUsage: Annotation({
        prompt: Annotation<number>({
          reducer: (x, y) => x + y,
          default: () => 0,
        }),
        completion: Annotation<number>({
          reducer: (x, y) => x + y,
          default: () => 0,
        }),
        total: Annotation<number>({
          reducer: (x, y) => x + y,
          default: () => 0,
        }),
      }),
      memoryUsage: Annotation({
        used: Annotation<number>({
          default: () => 0,
        }),
        total: Annotation<number>({
          default: () => 0,
        }),
        percentage: Annotation<number>({
          default: () => 0,
        }),
      }),
    }),
    checkpoint: Annotation({
      id: Annotation<string>({
        default: () => '',
      }),
      timestamp: Annotation<Date>({
        default: () => new Date(),
      }),
      version: Annotation<string>({
        default: () => '1.0.0',
      }),
    }),
  }),
})

// 导出状态类型
export type TMSAgentState = typeof AgentStateAnnotation.State
```

### 2. 创建工作流定义

创建`agent/graph/workflow-definition.ts`:

```typescript
import { StateGraph, START, END } from "@langchain/langgraph"
import { AgentStateAnnotation, TMSAgentState } from "../types/state-annotations"
import { SupervisorNode, createSupervisorNode } from "../nodes/supervisor-node"
import { ToolNode } from "@langchain/langgraph/prebuilt"
import { allTools } from "../tools"
import { ChatOpenAI } from "@langchain/openai"
import { MemorySaver } from "@langchain/langgraph/checkpoint"

// 节点类型定义
export type WorkflowNode =
  | "supervisor"
  | "tools"
  | "ui_generator"
  | "error_handler"
  | "checkpoint_saver"

// 工作流配置
export interface WorkflowConfig {
  llm?: ChatOpenAI
  maxRecursion?: number
  timeout?: number
  enableCheckpointing?: boolean
  enableStreaming?: boolean
  debug?: boolean
}

export class TMSWorkflow {
  private graph: any
  private config: WorkflowConfig
  private supervisorNode: SupervisorNode
  private toolNode: ToolNode

  constructor(config: WorkflowConfig = {}) {
    this.config = {
      maxRecursion: 10,
      timeout: 30000,
      enableCheckpointing: true,
      enableStreaming: true,
      debug: false,
      ...config
    }

    this.supervisorNode = createSupervisorNode(this.config.llm)
    this.toolNode = new ToolNode(allTools)

    this.graph = this.buildWorkflow()
  }

  private buildWorkflow(): any {
    // 创建状态图
    const workflow = new StateGraph(AgentStateAnnotation)

    // 添加节点
    workflow.addNode("supervisor", this.supervisorNode)
    workflow.addNode("tools", this.toolNode)
    workflow.addNode("ui_generator", this.uiGeneratorNode)
    workflow.addNode("error_handler", this.errorHandlerNode)

    // 如果启用检查点，添加检查点保存节点
    if (this.config.enableCheckpointing) {
      workflow.addNode("checkpoint_saver", this.checkpointSaverNode)
    }

    // 设置入口点
    workflow.addEdge(START, "supervisor")

    // 添加条件边：supervisor -> tools/ui_generator/END
    workflow.addConditionalEdges(
      "supervisor",
      this.routeFromSupervisor,
      {
        tools: "tools",
        ui_generator: "ui_generator",
        end: END,
        error: "error_handler"
      }
    )

    // 添加工具执行后的路由
    workflow.addEdge("tools", "supervisor")

    // 添加UI生成后的路由
    workflow.addEdge("ui_generator", "supervisor")

    // 添加错误处理后的路由
    workflow.addEdge("error_handler", "supervisor")

    // 添加检查点保存路由
    if (this.config.enableCheckpointing) {
      workflow.addEdge("checkpoint_saver", "supervisor")
    }

    return workflow
  }

  // 从supervisor节点的路由逻辑
  private routeFromSupervisor(state: TMSAgentState): string {
    const lastMessage = state.messages[state.messages.length - 1]

    try {
      // 检查是否有工具调用
      if (lastMessage?.tool_calls && lastMessage.tool_calls.length > 0) {
        return "tools"
      }

      // 检查是否需要生成UI
      if (state.ui.component && state.ui.component !== '') {
        return "ui_generator"
      }

      // 检查是否应该结束
      if (this.shouldEnd(state)) {
        return "end"
      }

      // 默认回到supervisor
      return "supervisor"

    } catch (error) {
      console.error('路由决策错误:', error)
      return "error_handler"
    }
  }

  // UI生成节点
  private uiGeneratorNode = async (state: TMSAgentState): Promise<Partial<TMSAgentState>> => {
    try {
      const startTime = Date.now()

      // 根据状态生成UI组件
      const uiComponent = this.generateUIComponent(state)

      return {
        ui: {
          ...state.ui,
          ...uiComponent,
          timestamp: new Date(),
        },
        metadata: {
          ...state.metadata,
          stepCount: state.metadata.stepCount + 1,
          performance: {
            ...state.metadata.performance,
            totalTime: state.metadata.performance.totalTime + (Date.now() - startTime)
          }
        }
      }

    } catch (error) {
      console.error('UI生成错误:', error)
      return {
        ui: {
          ...state.ui,
          error: `UI生成失败: ${error.message}`,
          timestamp: new Date(),
        },
        metadata: {
          ...state.metadata,
          errors: [
            ...state.metadata.errors,
            {
              type: 'UI_GENERATION_ERROR',
              message: error.message,
              timestamp: new Date(),
              handled: true
            }
          ]
        }
      }
    }
  }

  // 错误处理节点
  private errorHandlerNode = async (state: TMSAgentState): Promise<Partial<TMSAgentState>> => {
    const lastError = state.metadata.errors[state.metadata.errors.length - 1]

    // 生成错误响应
    const errorMessage = {
      role: 'assistant' as const,
      content: `抱歉，处理您的请求时遇到了问题：${lastError.message}

请尝试：
1. 重新描述您的需求
2. 提供更具体的信息
3. 或者联系技术支持

错误代码: ${lastError.type}`,
      timestamp: new Date(),
    }

    // 重置UI状态
    const uiReset = {
      component: 'ErrorComponent',
      props: {
        error: lastError,
        onRetry: () => console.log('Retry requested'),
        timestamp: new Date(),
      }
    }

    return {
      messages: [...state.messages, errorMessage],
      ui: uiReset,
      metadata: {
        ...state.metadata,
        stepCount: state.metadata.stepCount + 1,
      }
    }
  }

  // 检查点保存节点
  private checkpointSaverNode = async (state: TMSAgentState): Promise<Partial<TMSAgentState>> => {
    try {
      // 生成检查点
      const checkpoint = {
        id: `checkpoint_${Date.now()}`,
        timestamp: new Date(),
        state: state,
        metadata: {
          stepCount: state.metadata.stepCount,
          messageCount: state.messages.length,
          totalExecutionTime: state.metadata.performance.totalTime,
        }
      }

      // 这里可以将检查点保存到数据库或文件系统
      if (this.config.debug) {
        console.log('检查点已保存:', checkpoint.id)
      }

      return {
        metadata: {
          ...state.metadata,
          checkpoint: {
            id: checkpoint.id,
            timestamp: checkpoint.timestamp,
            version: '1.0.0'
          }
        }
      }

    } catch (error) {
      console.error('检查点保存失败:', error)
      return state
    }
  }

  // 生成UI组件
  private generateUIComponent(state: TMSAgentState): any {
    const { component, props } = state.ui
    const data = state.data

    // 根据组件类型生成相应的UI配置
    switch (component) {
      case 'OrderTable':
        return {
          component: 'OrderTable',
          props: {
            orders: data.orders || [],
            onOrderClick: (orderId: string) => console.log('Order clicked:', orderId),
            loading: false,
            ...props
          }
        }

      case 'OrderForm':
        return {
          component: 'OrderForm',
          props: {
            orderData: props || {},
            onSuccess: (order: any) => console.log('Order created:', order),
            loading: false
          }
        }

      case 'DispatchPlan':
        return {
          component: 'DispatchPlan',
          props: {
            orders: data.orders || [],
            vehicle: props?.vehicle,
            route: props?.route,
            onConfirm: () => console.log('Dispatch confirmed'),
            loading: false
          }
        }

      case 'VehicleTracker':
        return {
          component: 'VehicleTracker',
          props: {
            vehicle: props?.vehicle,
            currentLocation: props?.currentLocation,
            estimatedArrival: props?.estimatedArrival,
            route: props?.route,
            loading: false
          }
        }

      case 'PODViewer':
        return {
          component: 'PODViewer',
          props: {
            pod: props?.pod || data.pod,
            orderId: props?.orderId,
            loading: false
          }
        }

      case 'ReportViewer':
        return {
          component: 'ReportViewer',
          props: {
            report: props?.report,
            reportType: props?.reportType,
            loading: false
          }
        }

      default:
        return {
          component: 'ChatMessage',
          props: {
            message: props?.message || '处理完成',
            timestamp: new Date()
          }
        }
    }
  }

  // 判断是否应该结束会话
  private shouldEnd(state: TMSAgentState): boolean {
    const lastMessage = state.messages[state.messages.length - 1]

    // 检查最大递归深度
    if (state.metadata.stepCount >= (this.config.maxRecursion || 10)) {
      return true
    }

    // 检查是否有明确的结束意图
    if (lastMessage && typeof lastMessage.content === 'string') {
      const content = lastMessage.content.toLowerCase()
      if (content.includes('结束') || content.includes('完成') ||
          content.includes('再见') || content.includes('exit') ||
          content.includes('bye')) {
        return true
      }
    }

    // 检查是否已经解决了用户需求
    if (state.ui.component && state.ui.component !== 'ChatMessage') {
      const toolCalls = state.metadata.toolCalls.filter(tc =>
        tc.timestamp > new Date(Date.now() - 30000) // 最近30秒的工具调用
      )

      if (toolCalls.length === 0 && state.metadata.stepCount > 3) {
        return true
      }
    }

    return false
  }

  // 编译工作流
  compile(config?: any): any {
    const compileConfig = {
      checkpointer: this.config.enableCheckpointing ? new MemorySaver() : undefined,
      interruptBefore: [],
      interruptAfter: [],
      ...config
    }

    return this.graph.compile(compileConfig)
  }

  // 获取工作流图结构（用于调试和可视化）
  getGraphStructure(): any {
    return {
      nodes: this.graph.nodes,
      edges: this.graph.edges,
      entryPoint: this.graph.entryPoint,
      finishPoint: this.graph.finishPoint
    }
  }

  // 验证工作流配置
  validate(): { isValid: boolean; errors: string[] } {
    const errors: string[] = []

    try {
      // 检查节点连接
      const structure = this.getGraphStructure()

      // 验证入口点
      if (!structure.entryPoint) {
        errors.push('工作流缺少入口点')
      }

      // 验证节点存在性
      const requiredNodes = ['supervisor', 'tools']
      for (const node of requiredNodes) {
        if (!structure.nodes.includes(node)) {
          errors.push(`缺少必需节点: ${node}`)
        }
      }

      // 验证边连接
      if (structure.edges.length === 0) {
        errors.push('工作流缺少边连接')
      }

      return {
        isValid: errors.length === 0,
        errors
      }

    } catch (error) {
      return {
        isValid: false,
        errors: [`工作流验证失败: ${error.message}`]
      }
    }
  }

  // 重置工作流状态
  reset(): void {
    this.graph = this.buildWorkflow()
  }

  // 获取配置信息
  getConfig(): WorkflowConfig {
    return { ...this.config }
  }

  // 更新配置
  updateConfig(newConfig: Partial<WorkflowConfig>): void {
    this.config = { ...this.config, ...newConfig }
    this.reset()
  }
}

// 工作流工厂
export class WorkflowFactory {
  static create(config: WorkflowConfig = {}): TMSWorkflow {
    return new TMSWorkflow(config)
  }

  static createForRole(role: string, config?: WorkflowConfig): TMSWorkflow {
    const roleConfig: WorkflowConfig = {
      ...config,
      // 根据角色调整配置
      maxRecursion: role === 'manager' ? 15 : 10,
      timeout: role === 'dispatcher' ? 60000 : 30000,
    }

    return new TMSWorkflow(roleConfig)
  }

  static createWithDefaults(): TMSWorkflow {
    return new TMSWorkflow({
      maxRecursion: 10,
      timeout: 30000,
      enableCheckpointing: true,
      enableStreaming: true,
      debug: false
    })
  }
}
```

### 3. 创建执行器

创建`agent/graph/workflow-executor.ts`:

```typescript
import { TMSWorkflow, WorkflowConfig } from "./workflow-definition"
import { TMSAgentState } from "../types/state-annotations"
import { BaseMessage } from "@langchain/core/messages"

export interface ExecutionConfig {
  streamMode?: "values" | "updates"
  recursionLimit?: number
  timeout?: number
  debug?: boolean
}

export interface ExecutionResult {
  success: boolean
  finalState?: TMSAgentState
  error?: Error
  executionTime: number
  steps: ExecutionStep[]
  stats: ExecutionStats
}

export interface ExecutionStep {
  step: number
  node: string
  input: Partial<TMSAgentState>
  output: Partial<TMSAgentState>
  timestamp: Date
  duration: number
}

export interface ExecutionStats {
  totalSteps: number
  totalExecutionTime: number
  toolCalls: number
  llmCalls: number
  errors: number
  memoryUsage: {
    used: number
    total: number
    percentage: number
  }
}

export class WorkflowExecutor {
  private workflow: TMSWorkflow
  private compiledGraph: any

  constructor(workflow: TMSWorkflow) {
    this.workflow = workflow
    this.compiledGraph = workflow.compile()
  }

  // 执行工作流（同步）
  async execute(
    initialState: Partial<TMSAgentState>,
    config: ExecutionConfig = {}
  ): Promise<ExecutionResult> {
    const startTime = Date.now()
    const steps: ExecutionStep[] = []
    let currentState = { ...initialState }
    let stepCount = 0
    let hasError = false
    let finalError: Error | null = null

    try {
      // 执行工作流
      const result = await this.compiledGraph.invoke(initialState, {
        recursionLimit: config.recursionLimit || 10,
        timeout: config.timeout || 30000,
        streamMode: config.streamMode || "values"
      })

      const executionTime = Date.now() - startTime

      return {
        success: true,
        finalState: result,
        executionTime,
        steps,
        stats: this.calculateStats(result, executionTime)
      }

    } catch (error) {
      const executionTime = Date.now() - startTime

      return {
        success: false,
        error: error as Error,
        executionTime,
        steps,
        stats: this.calculateStats(currentState, executionTime, true)
      }
    }
  }

  // 流式执行工作流
  async *streamExecute(
    initialState: Partial<TMSAgentState>,
    config: ExecutionConfig = {}
  ): AsyncIterable<ExecutionStep> {
    const startTime = Date.now()
    let stepCount = 0

    try {
      const stream = await this.compiledGraph.stream(initialState, {
        streamMode: config.streamMode || "values",
        recursionLimit: config.recursionLimit || 10,
        timeout: config.timeout || 30000
      })

      for await (const chunk of stream) {
        stepCount++
        const step: ExecutionStep = {
          step: stepCount,
          node: this.detectCurrentNode(chunk),
          input: this.extractStepInput(chunk),
          output: chunk,
          timestamp: new Date(),
          duration: Date.now() - startTime
        }

        yield step
      }

    } catch (error) {
      const errorStep: ExecutionStep = {
        step: stepCount + 1,
        node: 'error',
        input: initialState,
        output: { error: error.message },
        timestamp: new Date(),
        duration: Date.now() - startTime
      }

      yield errorStep
    }
  }

  // 批量执行工作流
  async batchExecute(
    inputs: Partial<TMSAgentState>[],
    config: ExecutionConfig = {}
  ): Promise<ExecutionResult[]> {
    const results: ExecutionResult[] = []

    for (const input of inputs) {
      const result = await this.execute(input, config)
      results.push(result)
    }

    return results
  }

  // 带重试的执行
  async executeWithRetry(
    initialState: Partial<TMSAgentState>,
    config: ExecutionConfig & { maxRetries?: number } = {}
  ): Promise<ExecutionResult> {
    const maxRetries = config.maxRetries || 3
    let lastResult: ExecutionResult | null = null

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.execute(initialState, config)

        if (result.success) {
          return result
        }

        lastResult = result

        if (attempt < maxRetries) {
          console.log(`执行失败，第${attempt}次重试...`)
          // 添加延迟，避免立即重试
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt))
        }

      } catch (error) {
        lastResult = {
          success: false,
          error: error as Error,
          executionTime: 0,
          steps: [],
          stats: this.calculateStats(initialState, 0, true)
        }

        if (attempt < maxRetries) {
          console.log(`执行异常，第${attempt}次重试...`)
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt))
        }
      }
    }

    return lastResult || {
      success: false,
      error: new Error('所有重试都失败了'),
      executionTime: 0,
      steps: [],
      stats: this.calculateStats(initialState, 0, true)
    }
  }

  // 取消执行
  cancel(): void {
    // 实现取消逻辑
    console.log('执行已取消')
  }

  // 获取执行状态
  getExecutionStatus(): {
    isExecuting: boolean
    currentStep?: number
    currentNode?: string
  } {
    // 返回当前执行状态
    return {
      isExecuting: false, // 需要实现状态跟踪
      currentStep: 0,
      currentNode: 'supervisor'
    }
  }

  // 检测当前节点
  private detectCurrentNode(chunk: any): string {
    // 根据chunk内容推断当前执行的节点
    if (chunk.messages && chunk.messages.length > 0) {
      const lastMessage = chunk.messages[chunk.messages.length - 1]
      if (lastMessage.tool_calls) {
        return 'tools'
      }
      if (lastMessage.role === 'assistant') {
        return 'supervisor'
      }
    }

    if (chunk.ui && chunk.ui.component) {
      return 'ui_generator'
    }

    return 'unknown'
  }

  // 提取步骤输入
  private extractStepInput(chunk: any): Partial<TMSAgentState> {
    // 从chunk中提取步骤输入信息
    return {
      messages: chunk.messages || [],
      context: chunk.context || {},
      data: chunk.data || {},
      ui: chunk.ui || {}
    }
  }

  // 计算执行统计
  private calculateStats(
    state: TMSAgentState,
    executionTime: number,
    hasError: boolean = false
  ): ExecutionStats {
    const performance = state.metadata?.performance || {}
    const toolCalls = state.metadata?.toolCalls || []
    const errors = state.metadata?.errors || []

    return {
      totalSteps: state.metadata?.stepCount || 0,
      totalExecutionTime: executionTime,
      toolCalls: toolCalls.length,
      llmCalls: performance.llmCalls || 0,
      errors: hasError ? errors.length + 1 : errors.length,
      memoryUsage: performance.memoryUsage || {
        used: 0,
        total: 0,
        percentage: 0
      }
    }
  }

  // 重新编译工作流
  recompile(config?: any): void {
    this.compiledGraph = this.workflow.compile(config)
  }

  // 获取工作流实例
  getWorkflow(): TMSWorkflow {
    return this.workflow
  }
}

// 执行器工厂
export class ExecutorFactory {
  static create(workflow: TMSWorkflow): WorkflowExecutor {
    return new WorkflowExecutor(workflow)
  }

  static createWithConfig(
    workflowConfig: WorkflowConfig,
    executorConfig?: ExecutionConfig
  ): { workflow: TMSWorkflow; executor: WorkflowExecutor } {
    const workflow = new TMSWorkflow(workflowConfig)
    const executor = new WorkflowExecutor(workflow)

    return { workflow, executor }
  }
}
```

### 4. 创建导出文件

创建`agent/graph/index.ts`:

```typescript
export { TMSWorkflow, WorkflowFactory, type WorkflowConfig } from './workflow-definition'
export {
  WorkflowExecutor,
  ExecutorFactory,
  type ExecutionConfig,
  type ExecutionResult,
  type ExecutionStep,
  type ExecutionStats
} from './workflow-executor'

// 默认工作流配置
export const DEFAULT_WORKFLOW_CONFIG: WorkflowConfig = {
  maxRecursion: 10,
  timeout: 30000,
  enableCheckpointing: true,
  enableStreaming: true,
  debug: false
}

// 默认执行配置
export const DEFAULT_EXECUTION_CONFIG: ExecutionConfig = {
  streamMode: "values",
  recursionLimit: 10,
  timeout: 30000,
  debug: false
}

// 创建默认工作流实例
export function createDefaultWorkflow(): TMSWorkflow {
  return WorkflowFactory.createWithDefaults()
}

// 创建默认执行器实例
export function createDefaultExecutor(): WorkflowExecutor {
  const workflow = createDefaultWorkflow()
  return ExecutorFactory.create(workflow)
}
```

## 验证清单

- [ ] 状态注解定义完整且正确
- [ ] 工作流定义和节点连接正确
- [ ] 条件路由逻辑工作正常
- [ ] 执行器功能完整
- [ ] 流式处理支持正常
- [ ] 错误处理和重试机制完善
- [ ] 工作流编译和验证可用
- [ ] 性能监控和统计功能正常
- [ ] 单元测试覆盖率达到80%以上
- [ ] 集成测试通过

## 测试命令

```bash
# 工作流测试
npm test -- agent/graph/workflow-definition

# 执行器测试
npm test -- agent/graph/workflow-executor

# 状态注解测试
npm test -- agent/types/state-annotations

# 端到端工作流测试
npm run test:integration

# 性能测试
npm run test:performance
```

## 注意事项

- 工作流设计需要考虑性能和内存使用
- 状态管理需要处理好数据的序列化和反序列化
- 条件路由逻辑需要覆盖所有可能的场景
- 执行器需要支持取消和状态查询
- 错误处理需要提供详细的调试信息

## 下一步

完成本任务后，将进行任务028: 流式处理和实时响应实现，为工作流添加流式执行和实时交互能力，提升用户体验。