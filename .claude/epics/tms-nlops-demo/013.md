---
title: "TMS NL-Ops演示系统任务013: 回单管理API实现"
epic: "tms-nlops-demo"
task: "013"
phase: "2"
status: completed
priority: "high"
estimated_hours: 3
parallel: true
depends_on: ["001", "002", "003", "004", "005", "006", "007"]
tags: ["api", "documents", "proof-of-delivery", "backend", "typescript"]
created: "2025-09-20T04:20:45Z"
updated: "2025-09-20T04:20:45Z"
---

## 概述

实现回单管理相关的API接口，包括电子回单上传、验证和审核功能。构建完整的回单管理系统，支持数字化回单管理和验证流程。

## 目标

- 实现回单CRUD操作的API接口
- 创建回单数据模型和类型定义
- 实现文件上传和存储功能
- 集成回单验证和审核流程
- 提供回单查询和统计功能

## 技术栈

- **框架**: Next.js 15+ API Routes
- **语言**: TypeScript
- **数据库**: PostgreSQL (通过Prisma)
- **文件存储**: 本地存储或云存储
- **验证**: Zod schema validation
- **图像处理**: 图像压缩和OCR
- **API**: RESTful设计模式

## 实施步骤

### 1. 创建回单数据模型

更新`prisma/schema.prisma`:

```prisma
model Document {
  id            String   @id @default(cuid())
  documentNumber String   @unique
  documentType  DocumentType
  entityType    EntityType
  entityId      String
  title         String
  description  String?

  // 文件信息
  fileName      String
  originalName  String
  fileSize      Int      // 文件大小(字节)
  mimeType      String   // MIME类型
  filePath      String   // 文件存储路径
  fileUrl       String   // 文件访问URL
  checksum      String   // 文件校验和

  // 状态信息
  status        DocumentStatus @default(PENDING)
  visibility    DocumentVisibility @default(INTERNAL)

  // 审核信息
  verifiedBy    String?
  verifiedAt    DateTime?
  approvedBy    String?
  approvedAt    DateTime?
  rejectedBy    String?
  rejectedAt    DateTime?
  rejectionReason String?

  // 元数据
  tags          String[]
  metadata      String?  // JSON格式的额外元数据
  expiresAt     DateTime? // 过期时间
  version       Int      @default(1) // 版本号
  isLatest      Boolean  @default(true) // 是否最新版本
  parentDocumentId String? // 父文档ID(用于版本控制)

  // 关联信息
  customerId    String?
  customer      Customer? @relation(fields: [customerId], references: [id])
  orderId       String?
  order         Order?    @relation(fields: [orderId], references: [id])
  shipmentId    String?
  shipment      Shipment? @relation(fields: [shipmentId], references: [id])
  vehicleId     String?
  vehicle       Vehicle?  @relation(fields: [vehicleId], references: [id])
  driverId      String?
  driver        Driver?   @relation(fields: [driverId], references: [id])

  createdBy     String
  updatedBy     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // 关联关系
  reviews       DocumentReview[]
  signatures    DocumentSignature[]
  activityLogs  DocumentActivityLog[]
}

model DocumentReview {
  id            String   @id @default(cuid())
  documentId    String
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  reviewerId    String
  reviewerName  String
  reviewType    ReviewType
  status        ReviewStatus @default(PENDING)
  comments      String?
  rating        Int?     // 评分1-5
  decision      ReviewDecision?

  // 时间信息
  assignedAt    DateTime @default(now())
  startedAt     DateTime?
  completedAt   DateTime?
  dueDate       DateTime?

  // 审核结果
  isApproved    Boolean?
  conditions    String[] // 审核条件

  // 元数据
  metadata      String?  // JSON格式的额外信息
  notes         String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model DocumentSignature {
  id            String   @id @default(cuid())
  documentId    String
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  signerId      String
  signerName   String
  signerType   SignerType
  signatureData String   // 签名图片数据(Base64)
  signatureType SignatureType @default(WRITTEN)

  // 签署信息
  ipAddress     String?
  userAgent     String?
  location      String?  // 签署位置
  timestamp     DateTime @default(now())

  // 验证信息
  verificationCode String?
  isVerified    Boolean  @default(false)
  verifiedAt    DateTime?
  verifiedBy    String?

  // 状态信息
  status        SignatureStatus @default(PENDING)
  reason        String?  // 签署原因或说明

  createdAt     DateTime @default(now())
}

model DocumentActivityLog {
  id            String   @id @default(cuid())
  documentId    String
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  action        String   // 操作类型
  description   String   // 操作描述
  performedBy   String   // 操作人ID
  performerName String   // 操作人姓名
  changes       String?  // 变更内容(JSON格式)
  metadata      String?  // 额外元数据

  ipAddress     String?
  userAgent     String?
  timestamp     DateTime @default(now())
}

enum DocumentType {
  PROOF_OF_DELIVERY      // 回单
  BILL_OF_LADING         // 提单
  INVOICE                // 发票
  RECEIPT                // 收据
  CONTRACT               // 合同
  INSPECTION_REPORT      // 检验报告
  PHOTOGRAPH             // 照片
  CERTIFICATE            // 证书
  PERMIT                 // 许可证
  INSURANCE              // 保险单
  OTHER                  // 其他
}

enum EntityType {
  ORDER                  // 订单
  SHIPMENT               // 运单
  CUSTOMER               // 客户
  VEHICLE                // 车辆
  DRIVER                 // 驾驶员
  SYSTEM                 // 系统
}

enum DocumentStatus {
  PENDING                // 待处理
  UPLOADING              // 上传中
  UPLOADED               // 已上传
  PROCESSING             // 处理中
  PROCESSED              // 已处理
  VERIFIED               // 已验证
  APPROVED               // 已批准
  REJECTED               // 已拒绝
  EXPIRED                // 已过期
  ARCHIVED               // 已归档
}

enum DocumentVisibility {
  PUBLIC                 // 公开
  INTERNAL               // 内部
  RESTRICTED             // 受限
  CONFIDENTIAL           // 机密
}

enum ReviewType {
  MANUAL                 // 人工审核
  AUTOMATIC              // 自动审核
  QUALITY                // 质量审核
  COMPLIANCE             // 合规审核
  SECURITY               // 安全审核
}

enum ReviewStatus {
  PENDING                // 待审核
  IN_PROGRESS            // 审核中
  COMPLETED              // 已完成
  CANCELLED              // 已取消
}

enum ReviewDecision {
  APPROVE                // 批准
  REJECT                 // 拒绝
  REQUEST_CHANGES        // 要求修改
  ESCALATE               // 上报
}

enum SignerType {
  CUSTOMER               // 客户
  DRIVER                 // 驾驶员
  STAFF                  // 员工
  MANAGER                // 管理员
  EXTERNAL               // 外部人员
}

enum SignatureType {
  WRITTEN                // 手写签名
  DIGITAL                // 数字签名
  STAMP                  // 印章
  ELECTRONIC              // 电子签名
}

enum SignatureStatus {
  PENDING                // 待签署
  SIGNED                 // 已签署
  VERIFIED               // 已验证
  REJECTED               // 已拒绝
  EXPIRED                // 已过期
}
```

### 2. 创建回单类型定义

创建`src/types/document.ts`:

```typescript
import {
  DocumentType,
  EntityType,
  DocumentStatus,
  DocumentVisibility,
  ReviewType,
  ReviewStatus,
  ReviewDecision,
  SignerType,
  SignatureType,
  SignatureStatus
} from '@prisma/client'

export interface Document {
  id: string
  documentNumber: string
  documentType: DocumentType
  entityType: EntityType
  entityId: string
  title: string
  description?: string
  fileName: string
  originalName: string
  fileSize: number
  mimeType: string
  filePath: string
  fileUrl: string
  checksum: string
  status: DocumentStatus
  visibility: DocumentVisibility
  verifiedBy?: string
  verifiedAt?: Date
  approvedBy?: string
  approvedAt?: Date
  rejectedBy?: string
  rejectedAt?: Date
  rejectionReason?: string
  tags: string[]
  metadata?: string
  expiresAt?: Date
  version: number
  isLatest: boolean
  parentDocumentId?: string
  customerId?: string
  orderId?: string
  shipmentId?: string
  vehicleId?: string
  driverId?: string
  createdBy: string
  updatedBy: string
  createdAt: Date
  updatedAt: Date

  // 关联数据
  customer?: Customer
  order?: Order
  shipment?: Shipment
  vehicle?: Vehicle
  driver?: Driver
  reviews?: DocumentReview[]
  signatures?: DocumentSignature[]
  activityLogs?: DocumentActivityLog[]
}

export interface DocumentReview {
  id: string
  documentId: string
  reviewerId: string
  reviewerName: string
  reviewType: ReviewType
  status: ReviewStatus
  comments?: string
  rating?: number
  decision?: ReviewDecision
  assignedAt: Date
  startedAt?: Date
  completedAt?: Date
  dueDate?: Date
  isApproved?: boolean
  conditions: string[]
  metadata?: string
  notes?: string
  createdAt: Date
  updatedAt: Date
}

export interface DocumentSignature {
  id: string
  documentId: string
  signerId: string
  signerName: string
  signerType: SignerType
  signatureData: string
  signatureType: SignatureType
  ipAddress?: string
  userAgent?: string
  location?: string
  timestamp: Date
  verificationCode?: string
  isVerified: boolean
  verifiedAt?: Date
  verifiedBy?: string
  status: SignatureStatus
  reason?: string
  createdAt: Date
}

export interface DocumentActivityLog {
  id: string
  documentId: string
  action: string
  description: string
  performedBy: string
  performerName: string
  changes?: string
  metadata?: string
  ipAddress?: string
  userAgent?: string
  timestamp: Date
}

export interface CreateDocumentRequest {
  documentType: DocumentType
  entityType: EntityType
  entityId: string
  title: string
  description?: string
  file: File
  tags?: string[]
  metadata?: string
  expiresAt?: Date
  customerId?: string
  orderId?: string
  shipmentId?: string
  vehicleId?: string
  driverId?: string
}

export interface UpdateDocumentRequest {
  title?: string
  description?: string
  status?: DocumentStatus
  visibility?: DocumentVisibility
  tags?: string[]
  metadata?: string
  expiresAt?: Date
  rejectionReason?: string
}

export interface CreateDocumentReviewRequest {
  reviewerId: string
  reviewerName: string
  reviewType: ReviewType
  comments?: string
  rating?: number
  dueDate?: Date
  conditions?: string[]
  metadata?: string
  notes?: string
}

export interface CreateSignatureRequest {
  signerId: string
  signerName: string
  signerType: SignerType
  signatureData: string
  signatureType?: SignatureType
  reason?: string
  location?: string
}

export interface DocumentQueryParams {
  documentType?: DocumentType
  entityType?: EntityType
  entityId?: string
  status?: DocumentStatus
  visibility?: DocumentVisibility
  customerId?: string
  orderId?: string
  shipmentId?: string
  tags?: string[]
  startDate?: Date
  endDate?: Date
  page?: number
  limit?: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
}
```

### 3. 创建回单验证Schema

创建`src/validations/document.ts`:

```typescript
import { z } from 'zod'
import {
  DocumentType,
  EntityType,
  DocumentStatus,
  DocumentVisibility,
  ReviewType,
  ReviewStatus,
  ReviewDecision,
  SignerType,
  SignatureType
} from '@prisma/client'

export const createDocumentSchema = z.object({
  documentType: z.nativeEnum(DocumentType),
  entityType: z.nativeEnum(EntityType),
  entityId: z.string().min(1, '关联实体ID不能为空'),
  title: z.string().min(1, '文档标题不能为空'),
  description: z.string().optional(),
  tags: z.array(z.string()).optional(),
  metadata: z.string().optional(),
  expiresAt: z.date().optional(),
  customerId: z.string().optional(),
  orderId: z.string().optional(),
  shipmentId: z.string().optional(),
  vehicleId: z.string().optional(),
  driverId: z.string().optional()
})

export const updateDocumentSchema = z.object({
  title: z.string().min(1, '文档标题不能为空').optional(),
  description: z.string().optional(),
  status: z.nativeEnum(DocumentStatus).optional(),
  visibility: z.nativeEnum(DocumentVisibility).optional(),
  tags: z.array(z.string()).optional(),
  metadata: z.string().optional(),
  expiresAt: z.date().optional(),
  rejectionReason: z.string().optional()
})

export const createDocumentReviewSchema = z.object({
  reviewerId: z.string().min(1, '审核人ID不能为空'),
  reviewerName: z.string().min(1, '审核人姓名不能为空'),
  reviewType: z.nativeEnum(ReviewType),
  comments: z.string().optional(),
  rating: z.number().min(1).max(5, '评分必须在1-5之间').optional(),
  dueDate: z.date().optional(),
  conditions: z.array(z.string()).default([]),
  metadata: z.string().optional(),
  notes: z.string().optional()
})

export const createSignatureSchema = z.object({
  signerId: z.string().min(1, '签署人ID不能为空'),
  signerName: z.string().min(1, '签署人姓名不能为空'),
  signerType: z.nativeEnum(SignerType),
  signatureData: z.string().min(1, '签名数据不能为空'),
  signatureType: z.nativeEnum(SignatureType).default(SignatureType.WRITTEN),
  reason: z.string().optional(),
  location: z.string().optional()
})

export const documentQuerySchema = z.object({
  documentType: z.nativeEnum(DocumentType).optional(),
  entityType: z.nativeEnum(EntityType).optional(),
  entityId: z.string().optional(),
  status: z.nativeEnum(DocumentStatus).optional(),
  visibility: z.nativeEnum(DocumentVisibility).optional(),
  customerId: z.string().optional(),
  orderId: z.string().optional(),
  shipmentId: z.string().optional(),
  tags: z.array(z.string()).optional(),
  startDate: z.date().optional(),
  endDate: z.date().optional(),
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20),
  sortBy: z.string().default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
})

export const fileUploadSchema = z.object({
  file: z.instanceof(File, { message: '必须上传文件' })
    .refine(file => file.size <= 10 * 1024 * 1024, '文件大小不能超过10MB')
    .refine(
      file => [
        'image/jpeg',
        'image/png',
        'image/gif',
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      ].includes(file.type),
      '只支持JPG、PNG、GIF、PDF、DOC、DOCX格式的文件'
    )
})
```

### 4. 实现文件上传处理

创建`src/lib/fileUpload.ts`:

```typescript
import { writeFile, mkdir, unlink } from 'fs/promises'
import { join } from 'path'
import { existsSync } from 'fs'
import { createHash } from 'crypto'

export class FileUploadService {
  private static readonly UPLOAD_DIR = join(process.cwd(), 'uploads', 'documents')
  private static readonly MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB
  private static readonly ALLOWED_MIME_TYPES = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  ]

  static async uploadFile(file: File, entityType: string, entityId: string): Promise<{
    fileName: string
    filePath: string
    fileUrl: string
    fileSize: number
    mimeType: string
    checksum: string
  }> {
    // 验证文件
    this.validateFile(file)

    // 创建上传目录
    const entityDir = join(this.UPLOAD_DIR, entityType, entityId)
    await this.ensureDirectoryExists(entityDir)

    // 生成文件名
    const timestamp = Date.now()
    const random = Math.random().toString(36).substring(2, 8)
    const extension = this.getFileExtension(file.name)
    const fileName = `${timestamp}_${random}${extension}`
    const filePath = join(entityDir, fileName)

    // 读取文件内容
    const buffer = Buffer.from(await file.arrayBuffer())

    // 计算文件校验和
    const checksum = createHash('md5').update(buffer).digest('hex')

    // 保存文件
    await writeFile(filePath, buffer)

    // 生成文件URL
    const fileUrl = `/api/documents/files/${entityType}/${entityId}/${fileName}`

    return {
      fileName,
      filePath,
      fileUrl,
      fileSize: file.size,
      mimeType: file.type,
      checksum
    }
  }

  static async deleteFile(filePath: string): Promise<void> {
    try {
      if (existsSync(filePath)) {
        await unlink(filePath)
      }
    } catch (error) {
      console.error('删除文件失败:', error)
      throw new Error('删除文件失败')
    }
  }

  static async generateThumbnail(imagePath: string, thumbnailPath: string): Promise<void> {
    // 这里可以使用sharp等图像处理库生成缩略图
    // 简化版本，实际应用中需要实现图像处理
    try {
      // 如果是图片文件，可以生成缩略图
      // const image = await sharp(imagePath).resize(200, 200).toFile(thumbnailPath)
    } catch (error) {
      console.error('生成缩略图失败:', error)
    }
  }

  private static validateFile(file: File): void {
    if (file.size > this.MAX_FILE_SIZE) {
      throw new Error(`文件大小不能超过 ${this.MAX_FILE_SIZE / (1024 * 1024)}MB`)
    }

    if (!this.ALLOWED_MIME_TYPES.includes(file.type)) {
      throw new Error('不支持的文件类型')
    }
  }

  private static async ensureDirectoryExists(dirPath: string): Promise<void> {
    if (!existsSync(dirPath)) {
      await mkdir(dirPath, { recursive: true })
    }
  }

  private static getFileExtension(filename: string): string {
    const ext = filename.split('.').pop()
    return ext ? `.${ext.toLowerCase()}` : ''
  }

  static getFileUrl(entityType: string, entityId: string, fileName: string): string {
    return `/api/documents/files/${entityType}/${entityId}/${fileName}`
  }
}
```

### 5. 实现回单API路由

创建`src/app/api/documents/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { documentQuerySchema } from '@/validations/document'
import { getCurrentUser } from '@/lib/auth'

export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser()
    if (!user) {
      return NextResponse.json({ error: '未授权访问' }, { status: 401 })
    }

    const searchParams = request.nextUrl.searchParams
    const query = {
      documentType: searchParams.get('documentType') || undefined,
      entityType: searchParams.get('entityType') || undefined,
      entityId: searchParams.get('entityId') || undefined,
      status: searchParams.get('status') || undefined,
      visibility: searchParams.get('visibility') || undefined,
      customerId: searchParams.get('customerId') || undefined,
      orderId: searchParams.get('orderId') || undefined,
      shipmentId: searchParams.get('shipmentId') || undefined,
      tags: searchParams.get('tags') ? searchParams.get('tags')!.split(',') : undefined,
      startDate: searchParams.get('startDate') ? new Date(searchParams.get('startDate')!) : undefined,
      endDate: searchParams.get('endDate') ? new Date(searchParams.get('endDate')!) : undefined,
      page: parseInt(searchParams.get('page') || '1'),
      limit: parseInt(searchParams.get('limit') || '20'),
      sortBy: searchParams.get('sortBy') || 'createdAt',
      sortOrder: (searchParams.get('sortOrder') as 'asc' | 'desc') || 'desc'
    }

    const validatedQuery = documentQuerySchema.parse(query)

    const where: any = {}
    if (validatedQuery.documentType) where.documentType = validatedQuery.documentType
    if (validatedQuery.entityType) where.entityType = validatedQuery.entityType
    if (validatedQuery.entityId) where.entityId = validatedQuery.entityId
    if (validatedQuery.status) where.status = validatedQuery.status
    if (validatedQuery.visibility) where.visibility = validatedQuery.visibility
    if (validatedQuery.customerId) where.customerId = validatedQuery.customerId
    if (validatedQuery.orderId) where.orderId = validatedQuery.orderId
    if (validatedQuery.shipmentId) where.shipmentId = validatedQuery.shipmentId
    if (validatedQuery.tags && validatedQuery.tags.length > 0) {
      where.tags = {
        hasSome: validatedQuery.tags
      }
    }
    if (validatedQuery.startDate || validatedQuery.endDate) {
      where.createdAt = {}
      if (validatedQuery.startDate) where.createdAt.gte = validatedQuery.startDate
      if (validatedQuery.endDate) where.createdAt.lte = validatedQuery.endDate
    }

    const [documents, total] = await Promise.all([
      prisma.document.findMany({
        where,
        include: {
          customer: {
            select: {
              id: true,
              customerNumber: true,
              companyName: true
            }
          },
          order: {
            select: {
              id: true,
              orderNumber: true,
              cargoName: true
            }
          },
          shipment: {
            select: {
              id: true,
              shipmentNumber: true,
              status: true
            }
          },
          vehicle: {
            select: {
              id: true,
              licenseNumber: true,
              brand: true,
              model: true
            }
          },
          driver: {
            select: {
              id: true,
              name: true,
              phone: true
            }
          },
          reviews: {
            take: 3,
            orderBy: { createdAt: 'desc' }
          },
          signatures: {
            take: 3,
            orderBy: { createdAt: 'desc' }
          },
          _count: {
            select: {
              reviews: true,
              signatures: true,
              activityLogs: true
            }
          }
        },
        skip: (validatedQuery.page - 1) * validatedQuery.limit,
        take: validatedQuery.limit,
        orderBy: {
          [validatedQuery.sortBy]: validatedQuery.sortOrder
        }
      }),
      prisma.document.count({ where })
    ])

    return NextResponse.json({
      success: true,
      data: documents,
      pagination: {
        page: validatedQuery.page,
        limit: validatedQuery.limit,
        total,
        pages: Math.ceil(total / validatedQuery.limit)
      }
    })
  } catch (error) {
    console.error('获取文档列表失败:', error)
    return NextResponse.json(
      { error: '获取文档列表失败', details: error.message },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser()
    if (!user) {
      return NextResponse.json({ error: '未授权访问' }, { status: 401 })
    }

    const formData = await request.formData()
    const file = formData.get('file') as File
    const metadata = JSON.parse(formData.get('metadata') as string || '{}')

    // 验证数据
    const validatedData = createDocumentSchema.parse(metadata)
    fileUploadSchema.parse({ file })

    // 上传文件
    const fileInfo = await FileUploadService.uploadFile(
      file,
      validatedData.entityType,
      validatedData.entityId
    )

    // 生成文档编号
    const documentNumber = generateDocumentNumber(validatedData.documentType)

    // 创建文档记录
    const document = await prisma.document.create({
      data: {
        documentNumber,
        documentType: validatedData.documentType,
        entityType: validatedData.entityType,
        entityId: validatedData.entityId,
        title: validatedData.title,
        description: validatedData.description,
        fileName: fileInfo.fileName,
        originalName: file.name,
        fileSize: fileInfo.fileSize,
        mimeType: fileInfo.mimeType,
        filePath: fileInfo.filePath,
        fileUrl: fileInfo.fileUrl,
        checksum: fileInfo.checksum,
        status: DocumentStatus.UPLOADED,
        tags: validatedData.tags || [],
        metadata: validatedData.metadata,
        expiresAt: validatedData.expiresAt,
        customerId: validatedData.customerId,
        orderId: validatedData.orderId,
        shipmentId: validatedData.shipmentId,
        vehicleId: validatedData.vehicleId,
        driverId: validatedData.driverId,
        createdBy: user.id,
        updatedBy: user.id
      },
      include: {
        customer: {
          select: {
            id: true,
            customerNumber: true,
            companyName: true
          }
        },
        order: {
          select: {
            id: true,
            orderNumber: true,
            cargoName: true
          }
        },
        shipment: {
          select: {
            id: true,
            shipmentNumber: true,
            status: true
          }
        }
      }
    })

    // 添加活动日志
    await prisma.documentActivityLog.create({
      data: {
        documentId: document.id,
        action: 'UPLOAD',
        description: '文档上传成功',
        performedBy: user.id,
        performerName: user.name || '系统用户',
        changes: JSON.stringify({
          fileName: fileInfo.fileName,
          fileSize: fileInfo.fileSize,
          mimeType: fileInfo.mimeType
        }),
        ipAddress: request.headers.get('x-forwarded-for') || 'unknown',
        userAgent: request.headers.get('user-agent') || 'unknown'
      }
    })

    // 如果是回单，自动创建审核任务
    if (validatedData.documentType === DocumentType.PROOF_OF_DELIVERY) {
      await createAutoReview(document.id, user.id)
    }

    return NextResponse.json({
      success: true,
      data: document,
      message: '文档上传成功'
    }, { status: 201 })
  } catch (error) {
    console.error('文档上传失败:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: '数据验证失败', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: '文档上传失败', details: error.message },
      { status: 500 }
    )
  }
}

function generateDocumentNumber(documentType: DocumentType): string {
  const prefix = {
    [DocumentType.PROOF_OF_DELIVERY]: 'POD',
    [DocumentType.BILL_OF_LADING]: 'BOL',
    [DocumentType.INVOICE]: 'INV',
    [DocumentType.RECEIPT]: 'RCT',
    [DocumentType.CONTRACT]: 'CON',
    [DocumentType.INSPECTION_REPORT]: 'INS',
    [DocumentType.PHOTOGRAPH]: 'PHO',
    [DocumentType.CERTIFICATE]: 'CRT',
    [DocumentType.PERMIT]: 'PER',
    [DocumentType.INSURANCE]: 'INS',
    [DocumentType.OTHER]: 'DOC'
  }[documentType]

  const timestamp = Date.now().toString()
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0')
  return `${prefix}${timestamp.slice(-6)}${random}`
}

async function createAutoReview(documentId: string, userId: string) {
  // 为回单创建自动审核任务
  await prisma.documentReview.create({
    data: {
      documentId,
      reviewerId: userId,
      reviewerName: '系统审核',
      reviewType: ReviewType.AUTOMATIC,
      status: ReviewStatus.PENDING,
      dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24小时后到期
      conditions: ['文件格式正确', '文件完整性检查', '基本信息验证']
    }
  })
}
```

### 6. 实现单个文档操作路由

创建`src/app/api/documents/[id]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { updateDocumentSchema } from '@/validations/document'
import { getCurrentUser } from '@/lib/auth'
import { FileUploadService } from '@/lib/fileUpload'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser()
    if (!user) {
      return NextResponse.json({ error: '未授权访问' }, { status: 401 })
    }

    const document = await prisma.document.findUnique({
      where: { id: params.id },
      include: {
        customer: {
          select: {
            id: true,
            customerNumber: true,
            companyName: true
          }
        },
        order: {
          select: {
            id: true,
            orderNumber: true,
            cargoName: true,
            status: true
          }
        },
        shipment: {
          select: {
            id: true,
            shipmentNumber: true,
            status: true,
            originAddress: true,
            destinationAddress: true
          }
        },
        vehicle: {
          select: {
            id: true,
            licenseNumber: true,
            brand: true,
            model: true
          }
        },
        driver: {
          select: {
            id: true,
            name: true,
            phone: true,
            licenseNumber: true
          }
        },
        reviews: {
          include: {
            reviewer: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          },
          orderBy: { createdAt: 'desc' }
        },
        signatures: {
          orderBy: { createdAt: 'desc' }
        },
        activityLogs: {
          orderBy: { timestamp: 'desc' },
          take: 20
        }
      }
    })

    if (!document) {
      return NextResponse.json(
        { error: '文档不存在' },
        { status: 404 }
      )
    }

    return NextResponse.json({
      success: true,
      data: document
    })
  } catch (error) {
    console.error('获取文档详情失败:', error)
    return NextResponse.json(
      { error: '获取文档详情失败', details: error.message },
      { status: 500 }
    )
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser()
    if (!user) {
      return NextResponse.json({ error: '未授权访问' }, { status: 401 })
    }

    const body = await request.json()
    const validatedData = updateDocumentSchema.parse(body)

    const existingDocument = await prisma.document.findUnique({
      where: { id: params.id }
    })

    if (!existingDocument) {
      return NextResponse.json(
        { error: '文档不存在' },
        { status: 404 }
      )
    }

    const updateData: any = {
      updatedBy: user.id,
      updatedAt: new Date()
    }

    // 更新字段
    const updatableFields = [
      'title', 'description', 'status', 'visibility', 'tags',
      'metadata', 'expiresAt', 'rejectionReason'
    ]

    updatableFields.forEach(field => {
      if (validatedData[field] !== undefined) {
        updateData[field] = validatedData[field]
      }
    })

    // 状态变更处理
    if (validatedData.status && validatedData.status !== existingDocument.status) {
      if (validatedData.status === DocumentStatus.APPROVED) {
        updateData.approvedBy = user.id
        updateData.approvedAt = new Date()
      } else if (validatedData.status === DocumentStatus.REJECTED) {
        updateData.rejectedBy = user.id
        updateData.rejectedAt = new Date()
      } else if (validatedData.status === DocumentStatus.VERIFIED) {
        updateData.verifiedBy = user.id
        updateData.verifiedAt = new Date()
      }
    }

    const updatedDocument = await prisma.document.update({
      where: { id: params.id },
      data: updateData,
      include: {
        customer: {
          select: {
            id: true,
            customerNumber: true,
            companyName: true
          }
        },
        order: {
          select: {
            id: true,
            orderNumber: true,
            cargoName: true
          }
        },
        shipment: {
          select: {
            id: true,
            shipmentNumber: true,
            status: true
          }
        }
      }
    })

    // 添加活动日志
    await prisma.documentActivityLog.create({
      data: {
        documentId: params.id,
        action: 'UPDATE',
        description: '文档信息更新',
        performedBy: user.id,
        performerName: user.name || '系统用户',
        changes: JSON.stringify(validatedData),
        ipAddress: request.headers.get('x-forwarded-for') || 'unknown',
        userAgent: request.headers.get('user-agent') || 'unknown'
      }
    })

    return NextResponse.json({
      success: true,
      data: updatedDocument,
      message: '文档更新成功'
    })
  } catch (error) {
    console.error('更新文档失败:', error)
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: '数据验证失败', details: error.errors },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: '更新文档失败', details: error.message },
      { status: 500 }
    )
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getCurrentUser()
    if (!user) {
      return NextResponse.json({ error: '未授权访问' }, { status: 401 })
    }

    const document = await prisma.document.findUnique({
      where: { id: params.id }
    })

    if (!document) {
      return NextResponse.json(
        { error: '文档不存在' },
        { status: 404 }
      )
    }

    // 检查是否可以删除
    if (document.status === DocumentStatus.APPROVED || document.status === DocumentStatus.VERIFIED) {
      return NextResponse.json(
        { error: '已批准或已验证的文档不能删除' },
        { status: 400 }
      )
    }

    // 删除文件
    await FileUploadService.deleteFile(document.filePath)

    // 删除数据库记录
    await prisma.document.delete({
      where: { id: params.id }
    })

    return NextResponse.json({
      success: true,
      message: '文档删除成功'
    })
  } catch (error) {
    console.error('删除文档失败:', error)
    return NextResponse.json(
      { error: '删除文档失败', details: error.message },
      { status: 500 }
    )
  }
}
```

### 7. 实现文件下载API

创建`src/app/api/documents/files/[entityType]/[entityId]/[fileName]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { readFile, access } from 'fs/promises'
import { join } from 'path'
import { existsSync } from 'fs'
import { prisma } from '@/lib/prisma'

export async function GET(
  request: NextRequest,
  { params }: { params: { entityType: string; entityId: string; fileName: string } }
) {
  try {
    const { entityType, entityId, fileName } = params

    // 查找文档记录
    const document = await prisma.document.findFirst({
      where: {
        entityType: entityType.toUpperCase(),
        entityId,
        fileName
      }
    })

    if (!document) {
      return NextResponse.json(
        { error: '文件不存在' },
        { status: 404 }
      )
    }

    // 构建文件路径
    const filePath = join(process.cwd(), 'uploads', 'documents', entityType, entityId, fileName)

    // 检查文件是否存在
    if (!existsSync(filePath)) {
      return NextResponse.json(
        { error: '文件不存在' },
        { status: 404 }
      )
    }

    // 检查访问权限
    // 这里可以根据文档的visibility属性检查权限
    if (document.visibility === 'CONFIDENTIAL') {
      // 简化的权限检查，实际应用中需要更复杂的权限控制
      return NextResponse.json(
        { error: '无权访问此文件' },
        { status: 403 }
      )
    }

    // 读取文件
    const fileBuffer = await readFile(filePath)

    // 设置响应头
    const headers = new Headers()
    headers.set('Content-Type', document.mimeType)
    headers.set('Content-Disposition', `inline; filename="${document.originalName}"`)
    headers.set('Content-Length', fileBuffer.length.toString())
    headers.set('Cache-Control', 'public, max-age=3600')

    return new NextResponse(fileBuffer, {
      status: 200,
      headers
    })
  } catch (error) {
    console.error('文件下载失败:', error)
    return NextResponse.json(
      { error: '文件下载失败', details: error.message },
      { status: 500 }
    )
  }
}
```

### 8. 创建回单服务层

创建`src/services/documentService.ts`:

```typescript
import { prisma } from '@/lib/prisma'
import { DocumentType, DocumentStatus, ReviewType, ReviewStatus } from '@prisma/client'

export class DocumentService {
  static async getDocumentsByShipment(shipmentId: string, params: any = {}) {
    const { page = 1, limit = 20, documentType } = params

    const where: any = { shipmentId }
    if (documentType) where.documentType = documentType

    const [documents, total] = await Promise.all([
      prisma.document.findMany({
        where,
        include: {
          reviews: {
            orderBy: { createdAt: 'desc' }
          },
          signatures: {
            orderBy: { createdAt: 'desc' }
          }
        },
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' }
      }),
      prisma.document.count({ where })
    ])

    return {
      documents,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    }
  }

  static async verifyDocument(documentId: string, userId: string, comments?: string) {
    const document = await prisma.document.findUnique({
      where: { id: documentId }
    })

    if (!document) {
      throw new Error('文档不存在')
    }

    if (document.status !== DocumentStatus.PROCESSED) {
      throw new Error('只有已处理的文档才能验证')
    }

    const updatedDocument = await prisma.document.update({
      where: { id: documentId },
      data: {
        status: DocumentStatus.VERIFIED,
        verifiedBy: userId,
        verifiedAt: new Date()
      }
    })

    // 如果是回单，更新运单状态
    if (document.documentType === DocumentType.PROOF_OF_DELIVERY && document.shipmentId) {
      await this.updateShipmentStatusAfterPOD(document.shipmentId)
    }

    return updatedDocument
  }

  static async approveDocument(documentId: string, userId: string, comments?: string) {
    const document = await prisma.document.findUnique({
      where: { id: documentId }
    })

    if (!document) {
      throw new Error('文档不存在')
    }

    if (document.status !== DocumentStatus.VERIFIED) {
      throw new Error('只有已验证的文档才能批准')
    }

    const updatedDocument = await prisma.document.update({
      where: { id: documentId },
      data: {
        status: DocumentStatus.APPROVED,
        approvedBy: userId,
        approvedAt: new Date()
      }
    })

    // 添加活动日志
    await prisma.documentActivityLog.create({
      data: {
        documentId,
        action: 'APPROVE',
        description: '文档已批准',
        performedBy: userId,
        performerName: '系统用户',
        changes: JSON.stringify({ comments })
      }
    })

    return updatedDocument
  }

  static async rejectDocument(documentId: string, userId: string, reason: string) {
    const document = await prisma.document.findUnique({
      where: { id: documentId }
    })

    if (!document) {
      throw new Error('文档不存在')
    }

    const updatedDocument = await prisma.document.update({
      where: { id: documentId },
      data: {
        status: DocumentStatus.REJECTED,
        rejectedBy: userId,
        rejectedAt: new Date(),
        rejectionReason: reason
      }
    })

    // 添加活动日志
    await prisma.documentActivityLog.create({
      data: {
        documentId,
        action: 'REJECT',
        description: '文档被拒绝',
        performedBy: userId,
        performerName: '系统用户',
        changes: JSON.stringify({ reason })
      }
    })

    return updatedDocument
  }

  static async processDocument(documentId: string) {
    const document = await prisma.document.findUnique({
      where: { id: documentId }
    })

    if (!document) {
      throw new Error('文档不存在')
    }

    // 这里可以添加自动处理逻辑，如OCR识别、数据提取等
    // 简化版本，直接标记为已处理
    await prisma.document.update({
      where: { id: documentId },
      data: {
        status: DocumentStatus.PROCESSED
      }
    })

    return true
  }

  static async getDocumentStatistics(dateRange: { start: Date; end: Date }) {
    const [totalDocs, byType, byStatus, byEntity] = await Promise.all([
      prisma.document.count({
        where: {
          createdAt: {
            gte: dateRange.start,
            lte: dateRange.end
          }
        }
      }),
      prisma.document.groupBy({
        by: ['documentType'],
        where: {
          createdAt: {
            gte: dateRange.start,
            lte: dateRange.end
          }
        },
        _count: true
      }),
      prisma.document.groupBy({
        by: ['status'],
        where: {
          createdAt: {
            gte: dateRange.start,
            lte: dateRange.end
          }
        },
        _count: true
      }),
      prisma.document.groupBy({
        by: ['entityType'],
        where: {
          createdAt: {
            gte: dateRange.start,
            lte: dateRange.end
          }
        },
        _count: true
      })
    ])

    return {
      totalDocuments: totalDocs,
      byType: byType.reduce((acc, item) => {
        acc[item.documentType] = item._count
        return acc
      }, {}),
      byStatus: byStatus.reduce((acc, item) => {
        acc[item.status] = item._count
        return acc
      }, {}),
      byEntity: byEntity.reduce((acc, item) => {
        acc[item.entityType] = item._count
        return acc
      }, {})
    }
  }

  private static async updateShipmentStatusAfterPOD(shipmentId: string) {
    // 检查是否所有必需的回单都已提交并验证
    const podDocuments = await prisma.document.findMany({
      where: {
        shipmentId,
        documentType: DocumentType.PROOF_OF_DELIVERY,
        status: DocumentStatus.VERIFIED
      }
    })

    if (podDocuments.length > 0) {
      // 可以更新运单状态为已完成
      await prisma.shipment.update({
        where: { id: shipmentId },
        data: {
          status: 'DELIVERED'
        }
      })
    }
  }
}
```

## 验证清单

- [ ] 回单数据模型定义正确
- [ ] 文件上传功能正常
- [ ] 文件下载功能正常
- [ ] 文档CRUD操作完整
- [ ] 审核流程功能正常
- [ ] 签名功能正常
- [ ] 活动日志记录完整
- [ ] 权限控制有效
- [ ] 文件验证规则完善
- [ ] 统计功能准确

## 测试命令

```bash
# 运行API测试
npm run test:api

# 数据库迁移
npx prisma migrate dev

# 生成Prisma客户端
npx prisma generate
```

## 注意事项

- 确保文件上传安全性，防止恶意文件上传
- 文件存储需要考虑备份和冗余
- 大文件上传需要支持分片上传
- 权限控制需要根据实际业务需求调整
- 回单验证流程需要自动化程度
- 文档版本控制需要完善
- 文件过期和清理机制需要实现
- OCR和图像处理功能需要根据需求集成